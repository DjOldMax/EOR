{% extends 'project/learn.html' %}
{% load static %}
{% block content %}

<!-- Для навигации файл разделен на блоки согласно разделам:
1 раздел
2 раздел
3 раздел
4 раздел
5 раздел
6 раздел -->
<div id="container" class="container">	
    <div class="menu-panel">
        <a href="{% url 'Home' %}"><h3 style="color: red;">Нa домашнюю</h3></a>
        <input type="text" id="mySearch" style="width: 100%; font-size: 18px; padding: 11px; border: 1px solid #ddd;" onkeyup="myFunction()" placeholder="Поиск по содержанию" title="Введите категорию">
        <ul id="menu-toc" class="menu-toc">
            <li class="menu-toc-current"><a href="#item1">Титульный лист</a></li>
            <li><a href="#item2">Предисловие</a></li>
            <li><a href="#item3">Оглавление</a></li>
            <li><a href="#item4">1. Криптографические нападения и понятие о криптоанализе, надежность шифров</a></li>
            <li><a href="#item5">1.1. Основные понятия, используемые в криптографии</a></li>
            <li><a href="#item6">1.1.1. Основные термины и понятия, используемые в криптографии, модели открытого текста</a></li>
            <li><a href="#item7">1.1.2. Что должен знать и уметь криптограф</a></li>
            <li><a href="#item8">Контрольные вопросы</a></li>
            <li><a href="#item9">2. Криптографические нападения и понятие о криптоанализе, надежность шифров</a></li>
            <li><a href="#item10">2.1. Криптографическая стойкость алгоритмов шифрования</a></li>
            <li><a href="#item11">2.1.1. Теоретическая и практическая стойкость шифров</a></li>
            <li><a href="#item12">2.1.2. Теоретическая и практическая стойкость шифров</a></li>
            <li><a href="#item13">2.1.3. Теоретическая и практическая стойкость шифров</a></li>
            <li><a href="#item14">Контрольные вопросы</a></li>
            <li><a href="#item15">2.2. Криптоанализ, модель и параметры криптоаналитика</a></li>
            <li><a href="#item16">2.2.1. Криптоанализ, модель криптоаналитика</a></li>
            <li><a href="#item17">2.2.2. Метод встречи посередине</a></li>
            <li><a href="#item18">2.2.3. Виды атак на криптографические алгоритмы </a></li>
            <li><a href="#item19">2.2.4. Методы криптоанализа, использующие перебор ключей </a></li>
            <li><a href="#item20">Контрольные вопросы</a></li>
            <li><a href="#item21">3. Современные блочные шифры и методы из криптоанализа</a></li>
            <li><a href="#item22">3.1. Классические блочные алгоритмы шифрования. Альтернативные варианты построения блочных шифров</a></li>
            <li><a href="#item23">3.1.1. Модель итерационного блочного шифра</a></li>
            <li><a href="#item24">3.1.2. Структурные элементы блочного шифра блочного шифра</a></li>
            <li><a href="#item25">3.1.3. Основные схемы построения блочных шифров</a></li>
            <li><a href="#item26">3.1.4. Шифры структуры подстановочно-перестановочной сети </a></li>
            <li><a href="#item27">3.1.5. Альтернативные схемы построения блочных шифров</a></li>
            <li><a href="#item28">3.1.6. Режимы применения блочных шифров</a></li>
            <li><a href="#item29">Контрольные вопросы</a></li>
            <li><a href="#item30">3.2. Примеры блочных шифров</a></li>
            <li><a href="#item31">3.2.1. Блочный шифр DES</a></li>
            <li><a href="#item32">3.2.2. Блочный шифр ГОСТ−28147−89</a></li>
            <li><a href="#item33">3.2.3. Блочный шифр Rijndael (AES)</a></li>
            <li><a href="#item34">3.2.4. Блочный шифр ГОСТ Р 34.12-2015 «Кузнечик»</a></li>
            <li><a href="#item35">3.2.5. Блочный шифр RC6 </a></li>
            <li><a href="#item36">3.2.6. Блочный шифр Serpent </a></li>
            <li><a href="#item37">3.2.7. Блочный шифр Twofish </a></li>
            <li><a href="#item38">3.2.8. Блочный шифр MARS </a></li>
            <li><a href="#item39">Контрольные вопросы</a></li>
            <li><a href="#item40">3.3. Классификация методов криптоанализа блочных шифров</a></li>
            <li><a href="#item41">3.4. Основы дифференциального криптоанализа блочных шифров</a></li>
            <li><a href="#item42">3.4.1 Основные понятия дифференциального криптоанализа </a></li>
            <li><a href="#item43">3.4.2 Таблица распределения разностей, построение дифференциальной модели</a></li>
            <li><a href="#item44">3.4.3 Выполнение поиска ключа, оценивание сложности дифференциального криптоанализа</a></li>
            <li><a href="#item45">Контрольные вопросы</a></li>
            <li><a href="#item46">4. Вспомогательные криптографические примитивы</a></li>
            <li><a href="#item47">4.1. Вероятностное шифрование</a></li>
            <li><a href="#item48">4.1.1. Омофонические шифры</a></li>
            <li><a href="#item49">4.1.2. Шифры с вероятностным механизмом с увеличением размера блока данных</a></li>
            <li><a href="#item50">4.1.3. Вероятностное шифрование без увеличения размера блока данных</a></li>
            <li><a href="#item51">4.1.4. Вероятностное шифрование в асимметричных криптосистемах</a></li>
            <li><a href="#item52">Контрольные вопросы</a></li>
            <li><a href="#item53">4.2. Блочные шифры на основе управляемых операций</a></li>
            <li><a href="#item54">4.2.1. Управляемые криптографические примитивы</a></li>
            <li><a href="#item55">4.2.2. Недетерминированные шифры на основе управляемых операций</a></li>
            <li><a href="#item56">4.2.3. Итеративные шифры с раундовой функцией на основе управляемых операций</a></li>
            <li><a href="#item57">4.2.4. Пример блочного шифра на основе управляемых операций</a></li>
            <li><a href="#item58">Контрольные вопросы</a></li>
            <li><a href="#item59">4.3. Криптографические хэш функции</a></li>
            <li><a href="#item60">4.3.1. Структура и свойства хэш-функций</a></li>
            <li><a href="#item61">4.3.2. Построение хэш-функций на основе блочных шифров</a></li>
            <li><a href="#item62">4.3.3. Примеры хэш функций</a></li>
            <li><a href="#item63">4.3.4. Использование хэш функций при решении практических задач</a></li>
            <li><a href="#item64">Контрольные вопросы</a></li>
            <li><a href="#item65">4.4. Поточные алгоритмы шифрования</a></li>
            <li><a href="#item66">4.4.1. Определение и структурные элементы поточных шифров</a></li>
            <li><a href="#item67">4.4.2. Классификация поточных алгоритмов шифрования</a></li>
            <li><a href="#item68">4.4.3. Примеры поточных алгоритмов шифрования</a></li>
            <li><a href="#item69">Контрольные вопросы</a></li>
            <li><a href="#item70">5. Криптосистемы с открытым ключом</a></li>
            <li><a href="#item71">5.1. Асимметричные криптосистемы. История появления</a></li>
            <li><a href="#item72">5.1.1. Предпосылки к появлению асимметричных криптосистем</a></li>
            <li><a href="#item73">5.1.2. Асимметричные криптосистемы на основе задачи о ранце и уроки ее применения</a></li>
            <li><a href="#item74">5.1.3. Внедрение двухключевой криптографии на практике</a></li>
            <li><a href="#item75">Контрольные вопросы</a></li>
            <li><a href="#item76">5.2. Асимметричные алгоритмы шифрования</a></li>
            <li><a href="#item77">5.2.1. Основные определения</a></li>
            <li><a href="#item78">5.2.2. Криптосистема RSA</a></li>
            <li><a href="#item79">5.2.3. Криптосистема Рабина</a></li>
            <li><a href="#item80">5.2.4. Криптосистема Эль-Гамаля</a></li>
            <li><a href="#item81">5.2.5. Атака методом «человек в середине», инфраструктура открытых ключей</a></li>
            <li><a href="#item82">Контрольные вопросы</a></li>
            <li><a href="#item83">5.3. Криптосистемы на основе эллиптических кривых</a></li>
            <li><a href="#item84">5.3.1. Основные определения</a></li>
            <li><a href="#item85">5.3.2. Выбор параметров кривой</a></li>
            <li><a href="#item86">5.3.3. Криптосистема Эль-Гамаля с использованием эллиптических кривых</a></li>
            <li><a href="#item87">Контрольные вопросы</a></li>
            <li><a href="#item88">5.4. Методы криптоанализа асимметричных криптосистем</a></li>
            <li><a href="#item89">5.4.1. Методы факторизации</a></li>
            <li><a href="#item90">5.4.2. Методы дискретного логарифмирования</a></li>
            <li><a href="#item91">Контрольные вопросы</a></li>
            <li><a href="#item92">5.5. Электронно-цифровая подпись, алгоритмы ЭЦП</a></li>
            <li><a href="#item93">5.5.1. Основные определения</a></li>
            <li><a href="#item94">5.5.2. ЭЦП на основе алгоритма RSA</a></li>
            <li><a href="#item95">5.5.3. ЭЦП Эль-Гамаля</a></li>
            <li><a href="#item96">5.5.4. ЭЦП на эллиптических кривых</a></li>
            <li><a href="#item97">Контрольные вопросы</a></li>
            <li><a href="#item98">6. Криптографические методы в современных средствах защиты информации в компьютерных системах</a></li>
            <li><a href="#item99">6.1. Криптографические генераторы псевдослучайных последовательностей</a></li>
            <li><a href="#item100">6.1.1. Источники случайности в современных информационных системах</a></li>
            <li><a href="#item101">6.1.2. Классификация генераторов ПСП</a></li>
            <li><a href="#item102">Контрольные вопросы</a></li>
            <li><a href="#item103">6.2. Основы стегананографии</a></li>
            <li><a href="#item104">6.2.1. Общие сведения</a></li>
            <li><a href="#item105">6.2.2. Основные алгоритмы реализации стеганографических вложений</a></li>
            <li><a href="#item106">6.2.3. Атаки на стегосистемы</a></li>
            <li><a href="#item107">6.2.4. Методы обнаружения стеганографических вложений</a></li>
            <li><a href="#item108">Контрольные вопросы</a></li>
            <li><a href="#item109">6.3. Квантовая криптография</a></li>
            <li><a href="#item110">6.3.1. Квантовые каналы связи</a></li>
            <li><a href="#item111">6.3.2. Квантовые протоколы передачи ключей</a></li>
            <li><a href="#item112">6.3.3. Атаки на квантовые каналы связи</a></li>
            <li><a href="#item113">6.3.4. Квантовые компьютеры, квантовый криптоанализ</a></li>
            <li><a href="#item114">Контрольные вопросы</a></li>
            <li><a href="#item115">Справочные материалы</a></li>
        </ul>
    </div>

    <div class="bb-custom-wrapper">
        <div id="bb-bookblock" class="bb-bookblock">
            <div class="bb-item" id="item1">
                <div class="content">
                    <div class="scroller">
                        <p style="text-align: center;">ВОЕННО-КОСМИЧЕСКАЯ АКАДЕМИЯ имени А.Ф. Можайского</p>
                        <p></p>
                        <p></p>
                        <p></p>
                        <p></p>
                        <p></p>
                        <p style="text-align: center;">А.М. Ромаченко, С.В. Пилькевич</p>
                        <p></p>
                        <p></p>
                        <p></p>
                        <p style="text-align: center;"><strong>КРИПТОГРАФИЧЕСКИЕ МЕТОДЫ</strong></p>
                        <p style="text-align: center;"><strong>ЗАЩИТЫ ИНФОРМАЦИИ</strong></p>
                        <p></p>
                        <p></p>
                        <p></p>
                        <p style="text-align: center;">Учебное пособие</p>
                        <p></p>
                        <p></p>
                        <p></p>
                        <p style="text-align: center;">Учебное издание «Криптографические методы защиты информации» утверждено</p>
                        <p style="text-align: center;">решением редакционной коллегии Военно-космической академии имени А.Ф. Можайского</p>
                        <p style="text-align: center;">в качестве учебного пособия по дисциплине «Криптографические методы защиты информации»</p>
                        <p style="text-align: center;">и рекомендовано для обучающихся по основным профессиональным образовательным</p>
                        <p style="text-align: center;">программам высшего образования – программам специалитета по специальности</p>
                        <p style="text-align: center;">10.05.01 «Компьютерная безопасность», протокол № 4 от 13 апреля 2021 года</p>
                        <p></p>
                        <p></p>
                        <p></p>
                        <p></p>
                        <p style="text-align: center;"><img style="padding : 1px;" src="{% static 'project/images/img_00002.jpg' %}" alt=""></p>
                        <p style="text-align: center;">Санкт-Петербург</p>
                        <p style="text-align: center;">2022</p>
                        <p></p>
                        <p></p>
                        <p></p>
                        <p></p>
                    </div>
                </div>
            </div>
            <div class="bb-item" id="item2">
                <div class="content">
                    <div class="scroller">
                        <h2>Предисловие</h2>
                        <p>Одним из элементов современного мира стала острая необходимость в защите данных самого разного вида и назначения.
                            Без защиты информации уже невозможно представить себе устройство общества. Персональные данные, военные секреты,
                            базы данных различных учреждений, финансовая информация, технологические секреты и многое другое легко попали бы в руки злоумышленников,
                            что привело бы к серьезным последствиям. К счастью, ничего подобного не происходит. В случае необходимости защиты данных от посторонних,
                            на помощь приходят методы и алгоритмы защиты информации. Эти методы довольно разнообразны: от физических до программных, и выбор зависит от того,
                            какие данные будут защищаться. Для защиты бумажных документов достаточно ограничения доступа в помещение, где они хранятся, например,
                            с помощью пропускной системы. Для защиты персонального компьютера от загрузки со сторонних носителей информации необходимо использовать устройство доверенной загрузки и обеспечить невозможность вскрытия системного блока.
                            Эти способы являются физической защитой. В случае электронной информации все гораздо сложнее. Если украсть физический носитель, то это можно легко обнаружить,
                            электронную информацию можно скопировать сколько угодно раз, и это нельзя обнаружить пока скопированная информация не появится, к примеру, в газетном выпуске.
                            Современные бытовые флэш-носители обладают размерами 20*20*5 мм и имеют емкость, достаточную, чтобы украсть целую библиотеку,
                            правда для этого все еще нужен физический доступ к устройству, в котором хранится информация. Если компьютер с важной информацией подключен к сети,
                            то не требуется и физический доступ, злоумышленник может проникнуть в него из другой страны и скопировать к себе важную информацию.
                            Сложность защиты компьютерной информации породила разнообразие методов защиты. Как правило, ядром любой системы защиты данных являются криптографические методы информации.
                            Они преобразуют информацию с помощью математических методов так, чтобы злоумышленник не смог получить к ней доступ в случае, если у него оказались зашифрованные данные.
                            Кроме шифрования криптография выполняет множество других задач, таких как обмен ключами, авторизацию, аутентификацию и т.д.
                            Важно понимать, что несмотря на то, что криптографические методы дают высокую стойкость к взлому,
                            у злоумышленника есть много других способов получения доступа к информации в обход криптографии.
                            Это хищение ключей хакерами, использование вирусного кода, эксплуатация уязвимостей реализации криптоалгоритмов, операционных систем и программного обеспечения.
                            Таким образом криптография является только одним из компонентов системы защиты информации и слабость других частей может легко свести на нет все преимущества ее использования.</p>

                        <p><strong>Первый раздел</strong> посвящен рассмотрению основ криптографии как науки о засекречивании информации. Дан исторический обзор криптографических методов защиты информации.
                            Рассмотрены основные задачи защиты информации криптографическими методами, требования, предъявляемые к шифрам. простейшие шифры замены и методы их анализа.</p>

                        <p><strong>Второй раздел</strong> затрагивает область криптоанализа и надежности шифров. Рассматривается теоретическая и практическая стойкость шифров,
                             вводится понятие абсолютно стойкого шифра. При изложении вопросов, связанных с криптографическим анализом,
                              вербальное описание криптоаналитика конкретизируется через перечисление его параметров и дополняется формальной моделью.</p>

                        <p>Современные блочные шифры и методы их анализа рассмотрены в рамках <strong>третьего раздела</strong> учебного пособия.
                            Изложение материала построено по принципу «от общего к частному»: приводятся криптографические примитивы и возможные схемы построения блочных шифров,
                            после чего рассматриваются примеры отечественных и зарубежных алгоритмов, реализующих перечисленные подходы.</p>

                        <p>Вопросы криптографического анализа блочных алгоритмов шифрования излагаются в соответствии с современной классификационной схемой. Основное внимание уделено вероятностным методам, линейному, интегральному и алгебраическому методам криптоанализа.</p>
                        <p>Аспект привнесения в алгоритмы шифрования дополнительного элемента случайности раскрыт <strong> в четвертом разделе,</strong> при этом рассмотрены вопросы вероятностного шифрования, а также применение управляемых криптографических примитивов в практике конструирования блочных шифров. Несколько особняком стоит изложение материала, посвященного криптографическим хэш функциям, относящимся как к бесключевым, так и к одноключевым криптографическим алгоритмам и являющихся неотъемлемой частью схем электронной цифровой подписи. Завершает четвертый раздел описание поточных алгоритмов шифрования, включающее их классификацию, основные структурные элементы и примеры шифров.</p>
                        <p> <strong>Пятый раздел</strong> дает представление о криптосистемах с открытым ключом. Излагаются предпосылки и история их появления, рассматривается концепция двухключевой криптографии, первые алгоритмы и современные стандартизированные асимметричные криптосистемы, предназначенные для распределения ключевой информации по открытым каналам связи (системы выработки общего сеансового ключа) и для обеспечения целостности и аутентичности передаваемой информации (схемы электронной цифровой подписи). Кроме того, авторами уделено внимание методам криптоанализа асимметричных криптосистем.</p>
                        <p><strong>В рамках шестого раздела,</strong> озаглавленного как «Криптографические методы в современных средствах защиты информации в компьютерных системах» основной упор делается на описание криптографических генераторов псевдослучайных последовательностей, изложение основ стегананографии и элементов квантовой криптографии как в части построения квантовых протоколов передачи ключей, так и применения квантовых компьютеров в ходе проведения криптографического анализа асимметричных систем шифрования.</p>
                        <p>Таким образом, авторы считают, что им удалось выдержать «баланс» между теоретическим и практическим наполнением учебного пособия.</p>
                        <p>Учебное пособие разработали: канд. техн. наук А.М. Романченко (разделы 1, 2, подразд. 3.3−3.6 и раздел 4); <strong>доктор техн. наук С.В. Пилькевич</strong>  (подразд. 3.1 и 3.2, разделы 5, 6); подобран мультимедийный и справочный материал; предисловие написано совместно А.М. Романченко и С.В. Пилькевичем.</p>
                        <p>Авторы приносят благодарность Афанасьеву А.О., Демидько Е.С., Лабасюку Е.Ю., Майеру Э.Э., Тавалинскому А.Д. и Шайдарову Н.А., оказавшим помощь на завершающем этапе технического редактирования и формирования учебного издания.</p>
                    </div>
                </div>
            </div>
            <div class="bb-item" id="item3">
                <div class="content">
                    <div class="scroller">
                        <h2>Оглавление</h2>
                        <p class=rvps345>Предисловие</p>
                        <p class=rvps345>1. Основы криптографии как науки о засекречивании информации</p>
                        <p class=rvps345>2. Криптографические нападения и понятие о криптоанализе, надежность шифров</p>
                        <p class=rvps345>3. Современные блочные шифры и методы из криптоанализа</p>
                        <p class=rvps345>4. Вспомогательные криптографические примитивы</p>
                        <p class=rvps345>5. Криптосистемы с открытым ключом</p>
                        <p class=rvps345>6. Криптографические методы в современных средствах защиты информации в компьютерных системах</p>
                        <p class=rvps183 style="page-break-before: always;"><span class=rvts858><br></span></p>
                    </div>
                </div>
            </div>
            <!-- Начало 1го раздела -->
            <div class="bb-item" id="item4">
                <div class="content">
                    <div class="scroller">
                        <h2>Криптографические нападения и понятие о криптоанализе, надежность шифров</h2>
                        <p><strong>1.1.</strong> Основные понятия, используемые в криптографии</p>
                        <p><strong>1.2.</strong> История возникновения алгоритмов шифрования</p>
                    </div>
                </div>
            </div>
            <div class="bb-item" id="item5">
                <div class="content">
                    <div class="scroller">
                        <h2>Основные понятия, используемые в криптографии</h2>
                        <p><strong>1.1.1</strong> Основные термины и понятия, используемые в криптографии, модели открытого текста</p>
                        <p><strong>1.1.2</strong> Что должен знать и уметь криптограф</p>
                    </div>
                </div>
            </div>
            <div class="bb-item" id="item6">
                <div class="content">
                    <div class="scroller">
                        <h2>1.1.1. Основные термины и понятия, используемые в криптографии, модели открытого текста</h2>
                        <p>Центральным понятием в криптографии является алгоритм шифрования. Рассмотрим классическое определение алгоритма шифрования с секретным ключом.</p>
                        <p style="font-style: oblique; color:red">Определение 1.1.</p>
                        <p>Тройка алгоритмов, пространство сообщений <img style="vertical-align: middle;" src="{% static 'project/images/img_00012.png' %}" alt=""> и пространство ключей <img style="vertical-align: middle;" src="{% static 'project/images/img_00013.png' %}" alt=""> называется схемой шифрования с секретным ключом если:</p>
                        <p> - алгоритм генерации ключей <img style="vertical-align: middle;" src="{% static 'project/images/img_00014.png' %}" alt=""> является рандомизированым (осуществляющим случайный выбор из множества инвариантов) алгоритмом, возвращающим ключ <img style="vertical-align: middle;" src="{% static 'project/images/img_00015.png' %}" alt=""> ;</p>
                        <p> - алгоритм шифрования <img style="vertical-align: middle;" src="{% static 'project/images/img_00016.png' %}" alt=""> использует ключ <img style="vertical-align: middle;" src="{% static 'project/images/img_00017.png' %}" alt=""> и открытое сообщение <img style="vertical-align: middle;" src="{% static 'project/images/img_00018.png' %}" alt=""> для получения шифртекста ;</p>
                        <p> - алгоритм расшифрования <img style="vertical-align: middle;" src="{% static 'project/images/img_00019.png' %}" alt=""> использует ключ <img style="vertical-align: middle;" src="{% static 'project/images/img_00020.png' %}" alt=""> и шифртекст <img style="vertical-align: middle;" src="{% static 'project/images/img_00021.png' %}" alt=""> для получения открытого текста ;</p>
                        <p> - выполняется следующее равенство <img style="vertical-align: middle;" src="{% static 'project/images/img_00022.png' %}" alt=""> <img style="vertical-align: middle;" src="{% static 'project/images/img_00023.png' %}" alt="">. </p>
                        <p>Классической задачей криптографии является задача защищенного обмена сообщениями между абонентами с использованием открытого канала связи, который прослушивается злоумышленником (рис. 1.1). На данном рисунке: P </span><span class=rvts1638>−</span><span class=rvts4> это открытый текст, C – шифртекст, E – операция зашифрования, D – операция расшифрования. </span></p>
                        <p>В качестве информации, подлежащей криптографическому преобразованию, рассматриваются открытые тексты, построенные с использованием некоторого алфавита.</p>
                        <p style="font-style: oblique; color:red">Определение 1.2 </p>
                        <p> <strong>Криптология</strong> − это наука о математических методах защиты информации с помощью преобразования с использованием специальных математических алгоритмов. Криптология состоит из криптографии и криптоанализа.</p>
                        <p style="font-style: oblique; color:red">Определение 1.3 </p>
                        <p> <strong>Криптография</strong> −  это наука, которая изучает методы преобразования информации, обеспечивающие ее конфиденциальность, целостность и аутентичность.</p>
                        <p></p>
                        <p style="text-align: center;" ><img style="vertical-align: middle;" src="{% static 'project/images/img_00024.png' %}" alt=""></p>
                        <p style="text-align: center; font-style: oblique;" >Рис. 1.1. Основная задача криптографии − передача зашифрованных конфиденциальных данных</p>
                        <p style="text-align: center; font-style: oblique;" >с использованием открытого канала связи</p>
                        <p></p>
                        <p style="font-style: oblique; color:red">Определение 1.4 </p>
                        <p>Криптоанализ объединяет математические методы нарушения конфиденциальности и аутентичности информации без знания секретного ключа.</p>
                        <p style="font-style: oblique; color:red">Определение 1.5 </p>
                        <p> <strong>Конфиденциальность</strong> − это защищенность информации от ознакомления с ней лиц, не имеющих соответствующего права допуска с использование криптографических алгоритмов.</p>
                        <p style="font-style: oblique; color:red">Определение 1.6 </p>
                        <p> <strong>Целостность</strong> − невозможность несанкционированного изменения информации так, чтобы это не было обнаружено.</p>
                        <p style="font-style: oblique; color:red">Определение 1.7 </p>
                        <p> <strong>Аутентификация</strong> − это процесс установления подлинности сторон, обменивающихся сообщениями.</p>
                        <p style="font-style: oblique; color:red">Определение 1.8 </p>
                        <p> <strong>Зашифрование</strong> − процесс преобразования открытых данных в зашифрованные, при помощи алгоритма шифрования.</p>
                        <p style="font-style: oblique; color:red">Определение 1.9 </p>
                        <p> <strong>Расшифрование</strong> − процесс преобразования шифртекста данных в отрытый текст с использованием ключа.</p>
                        <p style="font-style: oblique; color:red">Определение 1.10 </p>
                        <p> <strong>Ключ</strong> − конкретное значение параметров криптографического алгоритма, обеспечивающее выбор одного преобразования из их семейства. Криптографический алгоритм должен обеспечивать невозможность восстановления открытого текста без знания ключа.</p>
                        <p> <strong>Пространство ключей</strong> − множество всех возможных значений ключа.</p>
                        <p style="font-style: oblique; color:red">Определение 1.11 </p>
                        <p> <strong>Авторизация</strong> − это предоставление определенному лицу прав на выполнение определенных действий; а также процесс проверки (подтверждения) данных прав при попытке выполнения этих действий.</p>
                        <p style="font-style: oblique; color:red">Определение 1.12 </p>
                        <p> <strong>Пароль</strong> − это условное слово или набор знаков, предназначенный для выполнения аутентификации или авторизации. Пароль можно преобразовать в ключ с использованием хэш-функций.</p>
                        <p style="font-style: oblique; color:red">Определение 1.13 </p>
                        <p> <strong>Система управления ключами</strong> − определяет порядок генерации новых ключей, использования ключей, хранения ключей, смены устаревших и скомпрометированных ключей, порядок уничтожения ключей.</p>
                        <p style="font-style: oblique; color:red">Определение 1.14 </p>
                        <p> <strong>Криптографическая атака</strong> −<span class=rvts4> это попытка криптоаналитика нарушить конфиденциальность, аутентичность или целостность информации. Успешную криптографическую атаку называют взломом.</span></p>
                        <p style="font-style: oblique; color:red">Определение 1.13 </p>
                        <p> <strong>Криптографическая стойкость</strong> −<span class=rvts4> это способность криптографического алгоритма противостоять криптографическим атакам.</span></p>
                        <p style="font-style: oblique; color:red">Определение 1.13 </p>
                        <p> <strong>Алфавит</strong> – это конечное множество знаков, используемых для кодирования информации. Главной характеристикой алфавита является его мощность – количество символов, составляющих алфавит. </span></p>
                        <p class=rvps317><span class=rvts4>Алфавит играет важную роль в трех аспектах криптографии:</span></p>
                        <p class=rvps595><span class=rvts1640>−</span><span class=rvts31> в задачах криптоанализа исторических шифров знание алфавита открытых текстов дает возможность применить частотный метод криптоанализа;</span></p>
                        <p class=rvps595><span class=rvts1640>−</span><span class=rvts31> для анализа криптостойкости паролей;</span></p>
                        <p class=rvps595><span class=rvts1640>−</span><span class=rvts31> для построения моделей открытого текста.</span></p>
                        <p class=rvps317><span class=rvts4>Большое значение имеет алфавит при рассмотрении стойкости паролей. Символы пароля, в отличие от ключа, неравновероятны и зависят от используемого языка и алфавита сообщения.</span></p>
                        <p class=rvps317><span class=rvts4>Рассмотрим задачу определения стойкости к перебору пароля пользователя. &nbsp;Предположим, что злоумышленнику известен алфавит, с использованием которого создан пароль. Формула для определения максимального количества паролей (пространства паролей) длины </span><span class=rvts51>п</span><span class=rvts4> с использованием алфавита мощности </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00025.png' %}" alt=""><span class=rvts4> имеет вид </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00026.png' %}" alt=""><span class=rvts4>. Например, для пароля длины 10 заданного с использованием строчных букв английского алфавита пространство паролей составит </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00027.png' %}" alt=""><span class=rvts4> или 205891132094649 вариантов. Размер пространства паролей сложно оценить непосредственно, число 205891132094649 – это много или мало? В этом случае можно воспользоваться простым подходом – определить, сколько равновероятных бит </span><span class=rvts30>ключа</span><span class=rvts4> составляют это пространство. Для этого необходимо найти логарифм по основанию 2 от пространства паролей: </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00028.png' %}" alt=""><span class=rvts4> бит. То есть рассмотренный ранее пароль соответствует ключу размером примерно 47 бит. Неплохо для форума о домашних животных, но недостаточно для важной информации, так как сегодня возможно перебрать ключ длиной примерно 80 бит. Как увеличить стойкость пароля? Это можно сделать двумя способами – или увеличить длину пароля, или увеличить размер алфавита путем добавления в пароль прописных букв, цифр и, возможно, спецсимволов. Рекомендуется использовать сразу оба подхода одновременно – и пароли длиной не менее 12 символов, и строчные/прописные буквы, цифры и спецсимволы в составе пароля.</span></p>
                        <p class=rvps317><span class=rvts4>Необходимо отметить, что реальные сообщения для любого конкретного языка, характеризуются определенной избыточностью. Статистика частот встречаемости элементов сообщений свидетельствует об их неравномерном распределении. В частности, для достаточно большого объема литературного текста на русском языке наиболее часто встречающимися буквами оказываются {</span><span class=rvts51>о,и</span><span class=rvts4>}, среди наиболее часто встречающихся букв английского языка символы {</span><span class=rvts51>e,t</span><span class=rvts4>}. </span></p>
                        <p class=rvps317><span class=rvts4>Отмеченные свойства языков используются криптоаналитиками при взломе шифров, поэтому для оценки свойств шифрованных текстов необходимо иметь соответствующую информацию о вероятностных характеристиках открытых сообщений. Предположим, что с помощью некоторого алгоритма шифрования зашифрован открытый текст, являющийся случайными данными, и, злоумышленник пытается угадать использовавшийся ключ. Какое бы ключ он не выбрал, в результате расшифрования всегда будут получаться данные, похожие на случайные. То есть даже если злоумышленник угадает ключ, то не сможет определить, что он правильный, нет никакого критерия правильности. Далее рассмотрим подходы к построению критерия правильного ключа для случая, когда известен тип открытого текста (за исключением данных похожих на случайные), например, открытый текст – это сообщение на английском языке. </span></p>
                        <p class=rvps317><span class=rvts4>С указанной целью используется ряд математических моделей открытых текстов, приведем примеры наиболее распространенных моделей, характеризующих их важные вероятностно-статистические свойства. Критерий правильности ключа с использованием этих моделей является степенью соответствия модели расшифрованного текста.</span></p>
                        <p class=rvps317><span class=rvts4>Простейшая вероятностная модель основана на учете частот </span><span class=rvts51>k</span><span class=rvts4>-грамм и приводит к следующей модели открытого текста. </span></p>
                        <p class=rvps317><span class=rvts4>Пусть </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00029.png' %}" alt=""><span class=rvts4> представляет собой массив, состоящий из приближений для вероятностей </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00030.png' %}" alt=""><span class=rvts4> появления </span><span class=rvts51>k</span><span class=rvts4>-грамм </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00031.png' %}" alt=""><span class=rvts4> в открытом тексте, </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00032.png' %}" alt=""><span class=rvts4>, </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00033.png' %}" alt=""><span class=rvts4> – алфавит открытого текста, </span><span class=rvts51>N</span><span class=rvts4> – длина текста.</span></p>
                        <p class=rvps317><span class=rvts38>Тогда источник "открытого текста" генерирует последовательность </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00034.png' %}" alt=""><span class=rvts38> знаков алфавита </span><span class=rvts95>А</span><span class=rvts38>, в которой </span><span class=rvts95>k</span><span class=rvts38>-грамма </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00035.png' %}" alt=""><span class=rvts38> появляется с вероятностью </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00036.png' %}" alt=""><span class=rvts38>, следующая </span><span class=rvts95>k</span><span class=rvts38>-грамма появляется с вероятностью </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00037.png' %}" alt=""><span class=rvts38> и т. д. Назовем построенную модель</span><span class=rvts4> открытого текста вероятностной моделью </span><span class=rvts51>k</span><span class=rvts4>-го приближения. То есть для модели открытого текста первого порядка все слова рассматриваются как независимые, имеющие определенную вероятность появления.</span></p>
                        <p class=rvps317><span class=rvts4>В вероятностной модели второго приближения первый знак </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00038.png' %}" alt=""><span class=rvts4> имеет вероятность </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00039.png' %}" alt=""><span class=rvts4>, а каждый следующий знак зависит от предыдущего и появляется с вероятностью</span></p>
                        <p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00040.png' %}" alt=""><span class=rvts4>,</span></p>
                        <p class=rvps597><span class=rvts4><br></span></p>
                        <p class=rvps605><span class=rvts4>где p</span><img style="vertical-align: middle;" src="{% static 'project/images/img_00041.png' %}" alt=""><span class=rvts4>, </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00042.png' %}" alt=""><span class=rvts4>.</span></p>
                        <p class=rvps317><span class=rvts4>Применив к расшифрованному тексту одну из моделей, можно построить критерий распознавания открытого текста и, соответственно, критерий правильности угадываемого ключа. При этом можно воспользоваться стандартными методами проверки статистических гипотез.</span></p>
                        <p style="font-style: oblique; color:red">Классификация криптографических методов защиты информации</p>
                        <p class=rvps317><span class=rvts4>Классификация криптографических методов защиты информации представлена на рис. 1.2. Она состоит из трех блоков:</span></p>
                        <p class=rvps317><span class=rvts4>1. Криптографические примитивы – алгоритмы, решающие одну задачу, например, вычисление электронной цифровой подписи (ЭЦП).</span></p>
                        <p class=rvps317><span class=rvts4>2. Методы криптоанализа криптографических примитивов.</span></p>
                        <p class=rvps317><span class=rvts4>3. Криптографические протоколы, показывают, как объединить несколько криптографических примитивов для решения конкретной практической задачи, например, обмена ключами.</span></p>
                        <p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00043.png' %}" alt=""></p>
                        <p style="text-align: center;"><span class=rvts51>Рис. 1.</span><span class=rvts51>2</span><span class=rvts51>. Классификация криптографических методов защиты информации</span></p>
                        <p class=rvps317><span class=rvts4><br></span></p>
                        <p class=rvps317><span class=rvts4>Рассмотрим краткое описание криптографических примитивов:</span></p>
                        <p class=rvps595><span class=rvts31>1) <strong>Cимметричные алгоритмы шифрования</strong></span><span class=rvts1640>−</span><span class=rvts31> одноключевые алгоритмы шифрования, для шифрования и расшифрования используется одинаковый ключ;</span></p>
                        <p class=rvps595><span class=rvts31>2) <strong>Блочные шифры</strong></span><span class=rvts1640>−</span><span class=rvts31> симметричные алгоритмы обрабатывающие данные блоками фиксированной длины, одинаковые блоки открытого текста преобразуются в одинаковые блоки шифртекста;</span></p>
                        <p class=rvps595><span class=rvts31>3) <strong>Поточные алгоритмы шифрования</strong></span><span class=rvts1640>−</span><span class=rvts31> симметричные алгоритмы шифрования обрабатывающие данные побитно или побайтно, в отличие от блочных шифров одинаковые символы открытого текста преобразуются в разные символы шифртекста;</span></p>
                        <p class=rvps595><span class=rvts31>4) <strong>Асимметричные алгоритмы шифрования</strong></span><span class=rvts1640>−</span><span class=rvts31> двухключевые алгоритмы шифрования; один ключ служит для зашифрования </span><span class=rvts1640>−</span><span class=rvts31> открытый, другой для расшифрования </span><span class=rvts1640>−</span><span class=rvts31> закрытый; применяются при генерации ЭЦП;</span></p>
                        <p class=rvps595><span class=rvts31>5) <strong>Хэш-функции</strong></span><span class=rvts1640>−</span><span class=rvts31> односторонние криптографические алгоритмы предназначенные для получения свертки сообщения; используются для генерации ЭЦП, проверки целостности и т. д.</span></p>
                        <p class=rvps595><span class=rvts31>6) <strong>Криптографические генераторы ПСЧ</strong> – алгоритмы генерации ПСЧ, статистически неотличимых от полностью случайного потока данных;</span></p>
                        <p class=rvps595><span class=rvts31>7) <strong>Алгоритмы ЭЦП</strong></span><span class=rvts1640>−</span><span class=rvts31> алгоритмы вычисления свертки сообщения, позволяющей подтвердить его авторство и целостность;</span></p>
                        <p class=rvps595><span class=rvts31>8) <strong>Методы криптоанализа</strong></span><span class=rvts1640>−</span><span class=rvts31> алгоритмы, позволяющие на основе анализа данных специального вида уменьшить вычислительную сложность расшифрования сообщения по сравнению с методом полного перебора;</span></p>
                        <p class=rvps595><span class=rvts31>9) <strong>Криптографические протоколы</strong></span><span class=rvts1640>−</span><span class=rvts31> описание распределенного алгоритма, в процессе выполнения которого два или более участника последовательно выполняют определенные действия и обмениваются сообщениями с использованием криптографических алгоритмов.</span></p>
                        <p class=rvps317><span class=rvts4>Необходимо отметить, что на основе криптографических алгоритмов одного класса могут быть созданы криптографические алгоритмы других классов. Так, например, широко распространено построение поточных шифров и хеш-функций на основе блочных шифров, поточных шифров на основе хеш-функций, генераторов ПСЧ на основе алгоритмов шифрования разных классов и т.&nbsp;д.</span></p>
                        <p class=rvps317 style="page-break-before: always;"><span class=rvts4><br></span></p>
                    </div>
                </div>
            </div>
            <div class="bb-item" id="item7">
                <div class="content">
                    <div class="scroller">
                        <h2>1.1.2. Что должен знать и уметь криптограф</h2>
                        <p class=rvps651><span class=rvts4> <strong>Необходимые теоретические знания:</strong> </span></p>
                        <p class=rvps652><span class=rvts31>1. Уверенное владение английским языком.</span></p>
                        <p class=rvps652><span class=rvts31>2. Базовое понимание основных языков программирования, т. е. C, C ++, Java и Python.</span></p>
                        <p class=rvps652><span class=rvts31>3. Сильные математические навыки; дискретная математика, линейная и матричная алгебра.</span></p>
                        <p class=rvps652><span class=rvts31>4. Базовое понимание теории сложности, теории информации и теории чисел.</span></p>
                        <p class=rvps652><span class=rvts31>5. Знания в области шифрования, цифровых подписей, обмена ключами.</span></p>
                        <p class=rvps652><span class=rvts31>6. Симметричная криптография: знание хеш-функций, кодов аутентификации сообщений и симметричного шифрования.</span></p>
                        <p class=rvps652><span class=rvts31>7. Знание теории алгоритмов и структур данных.</span></p>
                        <p class=rvps651><span class=rvts4> &nbsp; &nbsp; &nbsp; &nbsp;</span></p>
                        <p class=rvps651><span class=rvts4> <strong>Необходимые практические умения и навыки:</strong> </span></p>
                        <p class=rvps652><span class=rvts31>1. Защита важной информации от перехвата, копирования, изменения и / или удаления.</span></p>
                        <p class=rvps652><span class=rvts31>2. Оценка, анализ и выявление слабых мест в криптографических системах и алгоритмах безопасности.</span></p>
                        <p class=rvps652><span class=rvts31>3. Разработка надежных систем безопасности для предотвращения уязвимостей.</span></p>
                        <p class=rvps652><span class=rvts31>4. Разработка статистических и математических моделей для анализа данных и решения проблем безопасности.</span></p>
                        <p class=rvps652><span class=rvts31>5. Тестирование вычислительных моделей на надежность и точность.</span></p>
                        <p class=rvps652><span class=rvts31>6. Изучение, исследование и тестирование новых теорий и приложений криптологии.</span></p>
                        <p class=rvps652><span class=rvts31>7. Поиск слабых мест в линиях связи (например, беспроводная сеть, защищенный телефон, мобильные телефоны, электронная почта и т. д.).</span></p>
                        <p class=rvps652><span class=rvts31>8. Проверки того, что финансовые данные (например, кредитная карта, межбанковский счет, банкомат, онлайн-транзакции и т. д.) надежно зашифрованы и доступны только авторизованным пользователям.</span></p>
                        <p class=rvps652><span class=rvts31>9. Проверки того, что данные передачи сообщений (например, беспроводная сеть, защищенный телефон, мобильные телефоны, электронная почта и т. д.) не были незаконно доступны или изменены во время транспортировки.</span></p>
                        <p class=rvps652><span class=rvts31>10. Расшифровка сообщения и системы кодирования для военных, политических и/или правоохранительных органов.</span></p>
                        <p class=rvps652><span class=rvts31>11. Разработка и обновление методов для эффективной обработки криптографических задач.</span></p>
                        <p class=rvps652><span class=rvts31>12. Предоставление технической поддержки правительству, предприятиям и промышленности для решения проблем безопасности.</span></p>
                        <p class=rvps652><span class=rvts31>13. Консультирование коллег и научных сотрудников по криптографическим методам и приложениям.</span></p>
                        <p class=rvps653 style="page-break-before: always;"><span class=rvts4><br></span></p>
                    </div>
                </div>
            </div>

            <div class="bb-item" id="item8">
                <div class="content">
                    <div class="scroller">
                        <h2>Контрольные вопросы</h2>
                        <p class=rvps709><span class=rvts69>1. Что такое криптология, из чего она состоит?</span></p>
                        <p class=rvps709><span class=rvts69>2. Назовите основные требования к криптографическим системам.</span></p>
                        <p class=rvps709><span class=rvts69>3. Что такое конфиденциальность и аутентичность?</span></p>
                        <p class=rvps709><span class=rvts69>4. Назовите несколько областей применения криптографии.</span></p>
                        <p class=rvps709><span class=rvts69>5. Что такое алфавит? Рассчитайте количество различных сообщений длиной 6 символов для английского алфавита.</span></p>
                        <p class=rvps709><span class=rvts1826><br></span></p>
                        <p class=rvps249 style="page-break-before: always;"><span class=rvts4><br></span></p>
                    </div>
                </div>
            </div>
            <!-- Конец 1го раздела -->

            <!-- Начало 2го раздела -->
            <div class="bb-item" id="item9">
                <div class="content">
                    <div class="scroller">
                        <h2>2. Криптографические нападения и понятие о криптоанализе, надежность шифров</h2>
                        <p ></p>
                        <p >2.1. Криптографическая стойкость алгоритмов шифрования</p>
                        <p >2.2. Криптоанализ, модель и параметры криптоаналитика</p>
                    </div>
                </div>
            </div>

            <div class="bb-item" id="item10">
                <div class="content">
                    <div class="scroller">
                        <h2>2.1. Криптографическая стойкость алгоритмов шифрования</h2>
                        <p ></p>
                        <p >2.1.1. Теоретическая и практическая стойкость шифров</p>
                        <p >2.1.2. Оценивание криптостойкости алгоритмов шифрования</p>
                        <p >2.1.3. Понятие абсолютно стойкого шифра</p>
                        <p >Контрольные вопросы</p>
                    </div>
                </div>
            </div>

            <div class="bb-item" id="item11">
                <div class="content">
                    <div class="scroller">
                        <h2>2.1.1. Теоретическая и практическая стойкость шифров</h2>
                        <p class=rvps730><span class=rvts4>Теоретически стойкие Шифры по </span><a class=rvts65 href="#"  OnClick="javascript:NewWindow=window.open('1410.html','NewWindow','width=700,height=700,menubar=no,scrollbars');return false;">Шеннону</a><span class=rvts4> обладают следующими свойствами.</span></p>
                        <p class=rvps730><span class=rvts4>Невозможность получения на основе шифртекста вероятностной информации о тексте или используемом ключе.</span></p>
                        <p class=rvps730><span class=rvts4>Априорная вероятность открытого текста совпадает с апостериорной вероятностью (с учетом знания шифртекста), т. е. </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00072.png' %}" alt=""><span class=rvts4>.</span></p>
                        <p class=rvps730><span class=rvts30>Распределение вероятностей ключей равномерное. </span><span class=rvts4>Для любого открытого текста </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00073.png' %}" alt=""><span class=rvts4>, шифртекста </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00074.png' %}" alt=""><span class=rvts4> существует единственный ключ</span><img style="vertical-align: middle;" src="{% static 'project/images/img_00075.png' %}" alt=""><span class=rvts4> &nbsp;для которого </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00076.png' %}" alt=""><span class=rvts4>.</span></p>
                        <p class=rvps730><span class=rvts4>Раздел практической стойкости рассматривает атаки на шифры, не являющиеся совершенными. </span></p>
                        <p class=rvps730><span class=rvts4>Основной элемент практической стойкости по Шеннону это рабочая характеристика шифра, представляющая собой средний объем работы </span><span class=rvts51>W</span><span class=rvts4>(</span><span class=rvts51>N</span><span class=rvts4>), необходимый для определения ключа по криптограмме, состоящей из </span><span class=rvts51>N</span><span class=rvts4> букв, причем </span><span class=rvts51>N </span><span class=rvts4>&gt; </span><span class=rvts95>L</span><span class=rvts2803>0</span><span class=rvts38> </span><span class=rvts4>(объем перехвата больше расстояния единственности), измеренный в удобных элементарных операциях, например</span><span class=rvts38>, в количестве</span><span class=rvts4> операций зашифрования или расшифрования.</span></p>
                        <p class=rvps730><span class=rvts4>Ценность большинства данных со временем снижается, поэтому важно, чтобы рабочая характеристика шифра превышала по стоимости защищаемую информацию.</span></p>
                        <p class=rvps730><span class=rvts4>Сложность взлома алгоритмов классифицируется по категориям:</span></p>
                        <p class=rvps730><span class=rvts30>1. Полное вскрытие.</span><span class=rvts4> Криптоаналитик находит</span><span class=rvts38> ключ </span><span class=rvts95>k</span><span class=rvts38>, такой, что </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00077.png' %}" alt=""><span class=rvts38>.</span></p>
                        <p class=rvps730><span class=rvts30>2. Глобальная дедукция. </span><span class=rvts4>Криптоаналитик находит альтернативный алгоритм </span><span class=rvts51>A</span><span class=rvts4>, эквивалентный </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00078.png' %}" alt=""><span class=rvts4> без знания ключа.</span></p>
                        <p class=rvps730><span class=rvts30>3. Случайная (или частичная) дедукция. </span><span class=rvts4>Криптоаналитик находит ("крадет") открытый текст для перехваченного шифрованного сообщения.</span></p>
                        <p class=rvps730><span class=rvts30>4. Информационная дедукция. </span><span class=rvts4>Криптоаналитик добывает некоторую информацию о ключе или открытом тексте. Такой информацией могут быть несколько битов ключа, сведения о форме открытого текста и пр.</span></p>
                        <p class=rvps730><span class=rvts4>Алгоритм безусловно стоек, если восстановление невозможно при любом объеме шифртекста, полученного криптотаналитиком. На поверку безусловно стойки только одноразовые блокноты. Все остальные криптосистемы теоретически можно вскрыть методом грубой силы (прямой подбор ключа, лобовая атака).</span></p>
                        <p class=rvps730><span class=rvts4>Вычислительная стойкость по отношению к лобовой атаке зависит от длины ключа. </span></p>
                        <p class=rvps730><span class=rvts4>Вопросами вычислительной стойкости по отношению к другим методам криптоанализа (вероятностный, линейный, дифференциальный и пр.) занимается теория сложности вычислений.</span></p>
                        <p class=rvps730><span class=rvts4>Существует также понятие </span><span class=rvts51>имитостойкости шифра</span><span class=rvts4>, т. е. способность шифра противостоять попыткам противника по его имитации или подмене.</span></p>
                        <p class=rvps730 style="page-break-before: always;"><span class=rvts4><br></span></p>
                        <p class=rvps730><span class=rvts4><br></span></p>
                        <p class=rvps730><span class=rvts4><br></span></p>
                    </div>
                </div>
            </div>

            <div class="bb-item" id="item12">
                <div class="content">
                    <div class="scroller">
                        <h2>2.1.2 Оценивание криптостойкости алгоритмов шифрования</h2>
                        <p class=rvps317><span class=rvts4>При определении криптостойкости алгоритма шифрования, как правило, оцениваются три основных параметра </span><span class=rvts1638>−</span><span class=rvts4> объем и вид исходных данных для проведения криптоанализа, вычислительная сложность и требование к объему памяти. </span></p>
                        <p class=rvps317><span class=rvts4>Объем исходных данных обычно выражается в количестве блоков данных для блочных шифров и в байтах для остальных шифров (поточных, асимметричных и др.). Вычислительная сложность проведения криптоанализа оценивается в единицах операций шифрования/расшифрования, требуемых для проведения криптоанализа. Сложность проведения любого метода криптоанализа для произвольного алгоритма можно представить в виде точки на плоскости, где одной из осей будет вычислительная сложность, а другой </span><span class=rvts1638>−</span><span class=rvts4> количество требуемых исходных данных (рис. 2.1). </span></p>
                        <p class=rvps317><span class=rvts4>Перспективы и применимость любого метода криптоанализа удобно оценивать в сравнении с методом полного перебора, который теоретически способен гарантированно взломать любой шифр. Сложность метода полного перебора можно рассматривать как верхнюю границу сложности других методов криптоанализа. При этом, объем исходных данных, требуемых для полного перебора, обычно невелик </span><span class=rvts1638>−</span><span class=rvts4> порядка нескольких десятков байт или 2</span><span class=rvts1638>−</span><span class=rvts4>3 блока, а вычислительная сложность равна размерности пространства ключей, т. е. на рис. 2.1 метод полного перебора располагается почти на вертикальной оси. </span></p>
                        <p class=rvps4><span class=rvts4><br></span></p>
                        <p style="text-align: center;" ><img style="vertical-align: middle;" src="{% static 'project/images/img_00079.png' %}" alt=""></p>
                        <p style="text-align: center;" ><span class=rvts51>Рис. 2.1. Классы стойкости алгоритмов шифрования</span></p>
                        <p class=rvps4><span class=rvts51><br></span></p>
                        <p class=rvps741><span class=rvts4>Все алгоритмы шифрования и методы их криптоанализа, с точки зрения сложности их проведения, можно разделить на несколько групп:</span></p>
                        <p class=rvps875><span class=rvts1640>−</span><span class=rvts31> безопасные, недоступные для взлома (зеленая область);</span></p>
                        <p class=rvps875><span class=rvts1640>−</span><span class=rvts31> недоступные для практического взлома на современном этапе; это алгоритмы, криптоанализ которых имеет вычислительную сложность более чем </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00080.png' %}" alt=""><span class=rvts31>операций шифрования или для которых необходимо более чем &nbsp;</span><img style="vertical-align: middle;" src="{% static 'project/images/img_00081.png' %}" alt=""><span class=rvts31> байт данных для анализа;</span></p>
                        <p class=rvps875><span class=rvts1640>−</span><span class=rvts31> имеющие уязвимости, т. е. имеющие вычислительную сложность </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00082.png' %}" alt=""><span class=rvts31> и требуемый объем исходных данных </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00083.png' %}" alt=""><span class=rvts31>; несмотря на то, что такая атака теоретически может быть реализована, в практическом криптоанализе такая атака будет малоэффективной и реализуемой не всегда, так как такие объемы исходных данных и вычислительные мощности далеко не всегда доступны на практике;</span></p>
                        <p class=rvps875><span class=rvts1640>−</span><span class=rvts31> доступные для практического взлома, с вычислительной сложностью менее </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00084.png' %}" alt=""><span class=rvts31> и объемом исходных данных менее </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00085.png' %}" alt=""><span class=rvts31>; могут быть эффективно реализованы на практике.</span></p>
                        <p class=rvps741><span class=rvts38>Можно</span><span class=rvts4> подумать, что с ростом мощности компьютеров разрядность ключа, достаточная для обеспечения безопасности информации против атаки методом полного перебора, будет неограниченно расти. Однако это не так. Существуют фундаментальные ограничения вычислительной мощности, наложенные структурой вселенной: например, скорость передачи любого сигнала не может превышать скорость распространения света в вакууме, а количество атомов во Вселенной (из которых, в конечном счете, состоят компьютеры) огромно, но конечно.</span></p>
                        <p class=rvps741><span class=rvts4><br></span></p>
                        <p style="font-style: oblique; color:red">Предел, основанный на выделяемой Солнцем энергии</p>
                        <p class=rvps741><span class=rvts4>Все вычисления потребляют энергию. Согласно принципам классической термодинамики и статистической механики, потребление энергии при осуществлении необратимого преобразования (вычисления) имеет порядок </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00086.png' %}" alt=""><span class=rvts4>, где </span><span class=rvts51>T</span><span class=rvts4> – температура окружающей среды (по абсолютной шкале Кельвина), а </span><span class=rvts51>k</span><span class=rvts4> – постоянная Больцмана (равная </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00087.png' %}" alt=""><span class=rvts4> Дж/K). Мощность излучения Солнца составляет приблизительно </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00088.png' %}" alt=""><span class=rvts4> Вт; таким образом, за весь свой предполагаемый период существования – 10 млрд. лет, или </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00089.png' %}" alt=""><span class=rvts4> секунд – Солнце выделит около </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00090.png' %}" alt=""><span class=rvts4> Дж. Предположим, температура окружающей среды </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00091.png' %}" alt=""><span class=rvts4> градусов, тогда энергозатраты на одну операцию составляют </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00092.png' %}" alt=""><span class=rvts4> Дж. Значит, количество вычислительных операций, которые можно осуществить с использованием всей выделяемой Солнцем энергии, равно выделяемой мощности, поделенной на количество энергии, необходимой для осуществления одной операции, т. е. всего </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00093.png' %}" alt=""><span class=rvts4> операций. Такое количество операций потребовалось бы на взлом ключа из 73 десятичных цифр (или около 250 бит) методом прямого перебора при грубом предположении, что для проверки одного значения ключа необходима всего одна операция (на самом деле </span><span class=rvts1638>−</span><span class=rvts4> сотни операций). Для справки, количество атомов солнечной системы – около </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00094.png' %}" alt=""><span class=rvts4>.</span></p>
                        <p class=rvps741><span class=rvts4><br></span></p>
                        <p style="font-style: oblique; color:red">Предел, основанный на массе Земли</p>
                        <p class=rvps741><span class=rvts4>Масса Земли составляет порядка </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00095.png' %}" alt=""><span class=rvts4> кг. Масса протона – </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00096.png' %}" alt=""><span class=rvts4> кг, т. е. Земля содержит приблизительно </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00097.png' %}" alt=""><span class=rvts4> &nbsp;протонов. Сопоставим каждому протону отдельный компьютер и примем за скорость выполнения операции на таком компьютере время, за которое луч света проходит расстояние, равное диаметру этого протона (</span><img style="vertical-align: middle;" src="{% static 'project/images/img_00098.png' %}" alt=""><span class=rvts4> ).</span></p>
                        <p class=rvps741><span class=rvts4>Таким образом, каждый компьютер может выполнять </span><img style="vertical-align: middle;" src="{% static 'project/images/img_000099.png' %}" alt=""><span class=rvts4> операций в секунду. Если все эти компьютеры будут работать параллельно, их суммарное быстродействие составит </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00100.png' %}" alt=""><span class=rvts4> операций в секунду, т. е. </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00101.png' %}" alt="">><span class=rvts4> операций в секунду. Возраст Вселенной приблизительно 10 млрд. лет, т.&nbsp;е. </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00102.png' %}" alt=""><span class=rvts4> секунд. За весь период существования Вселенной такие гипотетические компьютеры размером с протон смогли бы выполнить </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00103.png' %}" alt=""><span class=rvts4> операций. При описанных предположениях относительно количества операций, необходимых на проверку значения ключа, такое количество операций позволит взломать ключ длиной 95 десятичных цифр, или 320 бит. Таким образом, минимальный размер ключа, необходимый для защиты информации от атак злоумышленника, будет расти по мере повышения быстродействия компьютеров; тем не менее, приведенные выше вычисления показывают, что существует возможность выбрать такую длину ключа, что атаку методом полного перебора будет осуществить в принципе невозможно, вне зависимости от повышения вычислительной мощности компьютеров или успехов в области классической теории алгоритмов </span></span></p>
                        <p class=rvps741><span class=rvts4>Задачу обеспечения криптостойкости алгоритма шифрования можно рассматривать с разных точек зрения. Можно выделить несколько необходимых, но недостаточных принципов проектирования алгоритмов шифрования: </span></p>
                        <p class=rvps875><span class=rvts1640>−</span><span class=rvts31> </span><span class=rvts93>принцип </span><a class=rvts2810 href="#"  OnClick="javascript:NewWindow=window.open('1420.html','NewWindow','width=700,height=700,menubar=no,scrollbars');return false;">Кергофа</a><span class=rvts93>, согласно</span><span class=rvts31> которому криптостойкость алгоритма шифрования не должна зависеть от хранения в секрете самого алгоритма, а должна быть основана только на знании секретного ключа;</span></p>
                        <p class=rvps875><span class=rvts1640>−</span><span class=rvts31> достаточный размер секретного ключа, должен обеспечивать </span><span class=rvts93>сложность перебора не менее чем</span><span class=rvts31> </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00104.png' %}" alt=""><span class=rvts31> (некоторые криптографы рекомендуют уже сегодня использовать ключи длиной не менее 160 бит);</span></p>
                        <p class=rvps875><span class=rvts1640>−</span><span class=rvts31> использование проверенных структурных элементов (подстановок и перестановок), имеющих хорошие характеристики;</span></p>
                        <p class=rvps875><span class=rvts1640>−</span><span class=rvts31> использование надежной структуры шифра, выполнение проверки криптостойкости шифра с помощью существующих методов криптоанализа.</span></p>
                        <p class=rvps741><span class=rvts4>Для асимметричных криптосистем характерно использование в составе алгоритма шифрования некоторой сложно разрешимой проблемы из теории чисел. Таким образом, вскрытие алгоритма шифрования становится эквивалентным решению этой сложной проблемы. Из таких сложных проблем можно назвать задачу факторизации (разложение больших чисел на простые множители), дискретное логарифмирование, извлечение квадратного корня по большому модулю специального вида, логарифмирование в поле точек эллиптической кривой. </span></p>
                        <p class=rvps741><span class=rvts4>Другим путем увеличения стойкости к взлому является использование сложной структуры алгоритма, обеспечивающей высокую степень перемешивания и рассеивания, лавинного эффекта, высоко-нелинейных операций и итерационной структуры алгоритма шифрования. Третьим вариантом является затруднение, для криптоаналитика, получения требуемого количества исходных данных для анализа. </span></p>
                        <p class=rvps741 style="page-break-before: always;"><span class=rvts4><br></span></p>
                        <p class=rvps876><span class=rvts10><br></span></p>
                    </div>
                </div>
            </div>
            <div class="bb-item" id="item13">
                <div class="content">
                    <div class="scroller">
                        <h2>2.1.3. Теоретическая и практическая стойкость шифров</h2>
                        <p class=rvps317><span class=rvts4>Традиционно в криптографии большой интерес представляла задача доказательства криптостойкости того или иного алгоритма, выражения ее в некоторых количественных единицах и определения ее верхней и нижней границы. Особый интерес </span><span class=rvts38>представлял вопрос существования</span><span class=rvts4> гарантированно стойкого шифра, который будет рассмотрен далее.</span></p>
                        <p class=rvps317><span class=rvts4>Рассматривая шифрование, как зависящее от ключа отображение </span><span class=rvts51>F</span><span class=rvts4> открытого текста в шифртекст </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00105.png' %}" alt=""><span class=rvts4>, можно определить задачу криптоаналитика, как вычисление исходного сообщения (открытого текста) по шифртексту. Одним из параметров, определяющих возможность решения данной задачи, является необходимый объем исходных данных. Существуют криптосистемы, в которых </span><span class=rvts30>любой</span><span class=rvts4> объем исходных данных недостаточен для того, чтобы взломать шифр, причем, независимо от используемых вычислительных ресурсов. Такие шифры называются безусловно или абсолютно стойкими. Фактически для таких шифров знание шифртекста не дает никакой дополнительной информации для криптоаналитика.</span></p>
                        <p class=rvps317><span class=rvts4>Если апостериорная вероятность того, что некоторое сообщение было зашифровано при известном шифртексте равна априорной вероятности без знания шифртекста, то такой шифр называется абсолютно (безусловно) стойким: </span></p>
                        <p style="text-align: center;" ><img style="vertical-align: middle;" src="{% static 'project/images/img_00106.png' %}" alt=""><span class=rvts2815>.</span></p>
                        <p class=rvps317><span class=rvts4>Это имеет место, когда вероятность того, что открытый текст принимает конкретное значение, не зависит от вида криптограммы. </span></p>
                        <p class=rvps317><span class=rvts4>«В шифре простой замены со случайным ключом имеется 26! отображений, соответствующих 26! способам, которыми мы можем заменить 26 различных букв. Все эти способы равновозможны, и поэтому каждый имеет априорную вероятность </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00107.png' %}" alt=""><span class=rvts4>. Если такой шифр применяется к "нормативному английскому языку" и предполагается, что шифровальщик противника не знает ничего об источнике сообщений, кроме того, что он создает английский текст, то априорными вероятностями различных сообщений из </span><span class=rvts51>N</span><span class=rvts4> букв являются просто их относительные частоты в нормативном английском тексте. </span></p>
                        <p class=rvps317><span class=rvts4>Если противник перехватил такую криптограмму из </span><span class=rvts51>N</span><span class=rvts4> букв, его апостериорные вероятности изменятся. Если </span><span class=rvts51>N</span><span class=rvts4> достаточно велико (скажем, 50 букв), имеется обычно единственное сообщение с апостериорной вероятностью, близкой к единице, в то время как все другие сообщения имею суммарную вероятность, близкую к нулю. Таким образом, имеется, по существу, единственное "решение" такой криптограммы. Для меньших </span><span class=rvts51>N</span><span class=rvts4> (скажем, </span><span class=rvts51>N</span><span class=rvts4>&nbsp;=&nbsp;15) обычно найдется много сообщений и ключей, вероятности которых сравнимы, и не найдется ни одного сообщения и ключа с вероятностью, близкой к единице. В этом случае "решение" криптограммы неоднозначно» </span></p>
                        <p class=rvps317><span class=rvts4>Для абсолютно стойкого шифра вероятности всех возможных решений равны и не зависят от количества имеющегося шифртекста. Поэтому невозможно отличить верный результат от неверного.</span></p>
                        <p class=rvps317><span class=rvts30> <strong>Шифр Вернама (одноразовый блокнот)</strong></span><span class=rvts4>. Назван в честь телеграфиста Гильберта Вернама, являющегося его изобретателем, придуман в 1917 году. Для получения шифртекста открытый текст складывается по модулю 2 (исключающее или) с ключом шифрования. При этом ключ должен обладать следующими свойствами:</span></p>
                        <p class=rvps595><span class=rvts31>1) быть истинно случайным (например, генерироваться с помощью аппаратных датчиков);</span></p>
                        <p class=rvps595><span class=rvts31>2) иметь размер, равный размеру открытого текста;</span></p>
                        <p class=rvps595><span class=rvts31>3) применяться только один раз и храниться в секрете. Если это требование будет нарушено, то криптограмму можно взломать с использованием разновидности частотного анализа.</span></p>
                        <p class=rvps317><span class=rvts4>При использовании на практике очень длинная ключевая последовательность записывается на некотором носителе (одноразовом блокноте), который имеется на приемной и передающей стороне, после использования строки и страницы данного блокнота уничтожаются. Изначально предназначенный для преобразования текстовых сообщений шифр легко расширяется для кодирования произвольных бинарных данных.</span></p>
                        <p class=rvps317><span class=rvts4>В работе Клода Шеннона доказывается абсолютная стойкость шифра Вернама, что обусловило его применение до настоящего времени при передаче особо важных сообщений государственными и военными структурами. Широкого распространения этот шифр не получил, так как его использование связано с трудоемкой задачей распределения ключей очень большого объема и обеспечения хранения их в секрете.</span></p>
                        <p class=rvps317><span class=rvts4>Важность шифра Вернама состоит в том, что при правильном применении это единственный шифр с абсолютной стойкостью, доказанной теоретически. Это связано с тем, что, не зная ключа, невозможно по имеющемуся шифртексту угадать/вычислить открытый текст. Любой открытый текст соответствующей длины будет равновероятным и у криптоаналитика нет возможности отличить один текст от другого. Расстояние единственности для шифра Вернама равно бесконечности.</span></p>
                        <p class=rvps317><span class=rvts30><strong>Теорема об абсолютной стойкости.</strong></span><span class=rvts4>Алгоритм шифрования является абсолютно стойким если размерность пространства ключей </span><span class=rvts51>K</span><span class=rvts4> больше или равна размерности пространства сообщений </span></p>
                        <p class=rvps317><span class=rvts4>Для других алгоритмов шифрования, при наличии определенного объема шифртекста, имеется возможность выполнить криптоанализ и найти соответствующий ему открытый текст. Минимальный объем шифртекста, для которого это возможно, называют расстоянием единственности, а шифры такого типа называют «условно стойкими». Так, например, для алгоритма DES и текстового английского сообщения расстояние единственности равно 66 бит или 8.2 символа ASCII. Расстояние единственности зависит от вида зашифрованных данных, его можно увеличить, например, с помощью предварительного сжатия сообщений перед шифрованием. Если избыточность стремится к нулю, даже тривиальный шифр будет недоступен для взлома с использованием только шифртекста. Важно понимать, что расстояние единственности это необходимое, но недостаточное условие взлома криптосистемы. Так, для множества криптоатак высокая вычислительная сложность не дает возможности их использования на практике даже при достаточном объеме исходных данных. Сложность взлома условно-стойких шифров основана на сложности решения криптоаналитической задачи. Для условно-стойкого шифра такие задачи должны быть вычислительно сложными или вычислительно неосуществимыми.</span></p>
                        <p class=rvps317 style="page-break-before: always;"><span class=rvts4><br></span></p>
                    </div>
                </div>
            </div>
            <div class="bb-item" id="item14">
                <div class="content">
                    <div class="scroller">
                        <h2>Конрольные вопросы</h2>
                        <p ></p>
                        <p >1. В чем измеряется криптостойкость шифров?</p>
                        <p >2. Назовите минимальные параметры криптосойкого шифра с точки зрения вычислительной сложности и объема исходных данных.</p>
                        <p >3. Что такое абсолютно стойкий шифр, в чем источник его стойкости?</p>
                        <p >4. Назовите основные классы сложности алгоритмов</p>
                    </div>
                </div>
            </div>
            <div class="bb-item" id="item15">
                <div class="content">
                    <div class="scroller">
                        <h2>2.2. Криптоанализ, модель и параметры криптоаналитика</h2>
                        <p ></p>
                        <p class=rvps526>2.2.1. Криптоанализ, модель криптоаналитика</p>
                        <p class=rvps526>2.2.2. Метод встречи посередине</p>
                        <p class=rvps526>2.2.3. Виды атак на криптографические алгоритмы<span class=rvts2998> &nbsp; &nbsp; &nbsp; &nbsp;</span></p>
                        <p class=rvps526>2.2.4. Методы криптоанализа, использующие перебор ключей</p>
                        <p class=rvps894>Контрольные вопросы</p>
                    </div>
                </div>
            </div>
            <div class="bb-item" id="item16">
                <div class="content">
                    <div class="scroller">
                        <h2>2.2.1. Криптоанализ, модель криптоаналитика</h2>
                        <p class=rvps803><span class=rvts4>Со времен появления первых криптографических методов и алгоритмов в криптографии наблюдалось противоборство «брони» и «снаряда». Чем большие успехи демонстрировали криптоаналитики, тем более сложные и изощренные алгоритмы шифрования изобретали криптографы. Продолжается это и теперь, хотя во многом вектор противостояния сместился в область компьютерных атак некриптографической направленности. Рассмотрим, что такое криптоанализ, какие бывают методы криптоанализа и их возможности. Кто такой криптоаналитик, какие ресурсы и методы есть в его распоряжении при ведении криптоаналитической работы?</span></p>
                        <p class=rvps803><span class=rvts4>Как было рассмотрено ранее, криптографические методы защиты информации рассматривают математические методы преобразования информации с целью обеспечения ее конфиденциальности и аутентичности. Это необходимо, как правило, для дальнейшей передачи этой информации по некоторому открытому каналу связи. Это может быть как обычный проводной канал связи, так и беспроводной, особенно удобный для прослушивания злоумышленником.</span></p>
                        <p class=rvps803><span class=rvts4>В общем виде система удаленного информационного обмена и ее участники представлены</span><span class=rvts38> на рис. 2.2. </span><span class=rvts4>Участники подразделяются на легальных и нелегальных. Нелегальный участник может иметь как активную, так и пассивную стратегию поведения. При изучении криптографических протоколов мы будем рассматривать оба вида нарушителей, при изучении криптографических методов защиты информации актуальной является модель пассивного нарушителя, задачей которого является перехват информации из каналов связи с последующей обработкой этой информации специальными математическими методами. Такая обработка с целью получения доступа к конфиденциальной информации без знания секретного ключа называется криптоанализом.</span></p>
                        <p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00109.png' %}" alt=""></p>
                        <p style="text-align: center;"><span class=rvts51>Рис. 2.2. </span><span class=rvts40>Система удаленного информационного обмена и ее участники </span></p>
                        <p style="font-style: oblique; color:red">Определение 2.1</p>
                        <p class=rvps803><span class=rvts166><strong>Криптоанализ</strong></span><span class=rvts4> </span><span class=rvts1638>−</span><span class=rvts4> это совокупность методов и алгоритмов, позволяющих прочитать зашифрованное сообщение без знания ключа. Это может быть сделано или с помощью вычисления ключа на основе имеющихся данных или нахождение возможности безключевого чтения.</span></p>
                        <p class=rvps803><span class=rvts4><br></span></p>
                        <p class=rvps803><span class=rvts4>Вместо нахождения ключа для некоторых алгоритмов может быть вычислен эквивалентный ключ, дающий результат шифрования/расшифрования аналогичный исходному ключу. Этот феномен объясняется тем, что, как правило, БШ используют не исходный ключ для шифрования, а некоторое его расширение, вычисляемое на основе ключа пользователя. Если функция для расширения ключа имеет уязвимости, например, с большой вероятностью допускает коллизии, то различные исходные ключи могут преобразоваться к одинаковым расширенным ключам. При вычислении ключа также не обязательно получить именно исходный ключ, а достаточно вычислить его расширение, используемое при шифровании.</span></p>
                        <p class=rvps803><span class=rvts4>Сложность атаки на криптографический алгоритм оценивается по двум параметрам, первый отражает объем и тип исходных данных необходимых для анализа, второй связан с вычислительными ресурсами (временными), для проведения атаки. Первый из них оценивается по количеству текстов (блоков данных) заданного вида, второй оценивается по количеству требуемых для проведения атаки операций шифрования несмотря на то, что атака может напрямую быть не связаны с выполнением шифрования. Кроме этого, иногда рассматривается такой ресурс как объем памяти, требуемый для проведения атаки.</span></p>
                        <p class=rvps803><span class=rvts4>Итак, модель криптоаналитика предполагает, что:</span></p>
                        <p class=rvps902><span class=rvts31>1. Криптоаналитик имеет в распоряжении достаточный объем данных заданного вида, даже если это трудноосуществимо на практике.</span></p>
                        <p class=rvps902><span class=rvts31>2. Криптоаналитик обладает полными знаниями о используемых криптографических алгоритмах (шифрования и расшифрования) и особенностях их реализации (согласно принципу Кирхгофа).</span></p>
                        <p class=rvps902><span class=rvts31>3. Криптоаналитик обладает временными и вычислительными ресурсами, стоимость которых соответствует стоимости защищаемой информации.</span></p>
                        <p class=rvps902><span class=rvts31>4. Для некоторых видов криптоанализа предполагается, что криптоаналитик имеет в наличии устройство шифрования, имеет возможность влиять на его работу с использованием непредусмотренных воздействий и замерять физические параметры его функционирования.</span></p>
                        <p class=rvps902><span class=rvts31>5. Криптоаналитику не известна какая-либо ключевая информация.</span></p>
                        <p class=rvps902><span class=rvts31><br></span></p>
                        <p style="font-style: oblique; color:red">Определение 2.2</p>
                        <p class=rvps803><span class=rvts4>Криптостойкостью называется характеристика шифра, определяющая его стойкость к расшифрованию без знания секретного ключа, т. е. к криптоатаке. Расшифрование без знания секретного ключа называется взломом. Показатель криптостойкости главный параметр любой криптосистемы. В качестве показателей криптостойкости используются:</span></p>
                        <p class=rvps902><span class=rvts1640>−</span><span class=rvts31> размерность ключевого пространства или вероятность подбора ключа за данные время с данными ресурсами;</span></p>
                        <p class=rvps902><span class=rvts1640>−</span><span class=rvts31> количество операций или время необходимое для взлома шифра с заданной вероятностью;</span></p>
                        <p class=rvps803><span class=rvts1638>−</span><span class=rvts4> стоимость вычисления ключевой информации или исходного текста.</span></p>
                        <p class=rvps803 style="page-break-before: always;"><span class=rvts4><br></span></p>
                        <p class=rvps903><span class=rvts4><br></span></p>
                    </div>
                </div>
            </div>
            <div class="bb-item" id="item17">
                <div class="content">
                    <div class="scroller">
                        <h2>2.2.2. Метод встречи посередине</h2>
                        <p class=rvps317><span class=rvts4>Рассмотрим универсальный метод криптоанализа, который основан на парадоксе дней рождения и подходит для взлома многих алгоритмов с секретным ключом. Парадокс дней рождения состоит в том, что если мы возьмем группу из 23 случайных человек то с большой вероятностью у пары из них дни рождения совпадут, хотя вероятность того, что в группе из 23 человек встретится человек с заранее заданным днем рождения составляет </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00110.png' %}" alt=""><span class=rvts4>. В общем виде парадокс дней рождения формулируется так: если </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00111.png' %}" alt=""><span class=rvts4> предметов выбираются с возвращением из некоторой совокупности </span><span class=rvts51>b,</span><span class=rvts4> то вероятность того, что два из них совпадут, равна </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00112.png' %}" alt=""><span class=rvts4>. Метод встречи посредине основан на парадоксе дней рождения.</span></p>
                        <p class=rvps317><span class=rvts4>Пусть необходимо найти ключ </span><span class=rvts51>k</span><span class=rvts4> по открытому тексту </span><span class=rvts51>x </span><span class=rvts4>и шифртексту </span><span class=rvts51>y</span><span class=rvts4>. Если множество ключей замкнуто относительно композиции, т.&nbsp;е. для любых ключей </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00113.png' %}" alt=""><span class=rvts4> найдется ключ </span><span class=rvts51>k</span><span class=rvts4> такой, что результат последовательного шифрования с ключами </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00114.png' %}" alt=""><span class=rvts4> равен результату шифрования этого же текста с ключом </span><span class=rvts51>k</span><span class=rvts4>, т.&nbsp;е. </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00115.png' %}" alt=""><span class=rvts4>, то это свойство можно использовать для взлома шифров. Поиск ключа </span><span class=rvts51>k</span><span class=rvts4> сведем к поиску эквивалентной ему пары ключей </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00116.png' %}" alt=""><span class=rvts4>. Для текста </span><span class=rvts51>x</span><span class=rvts4> построим базу данным содержащих множество ключей </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00117.png' %}" alt=""><span class=rvts4> и соответствующих им криптограмм </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00118.png' %}" alt=""><span class=rvts4>(x) &nbsp;и упорядочим ее по криптограммам </span><span class=rvts51>с</span><span class=rvts4>. Объем базы данных выбираем равным </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00119.png' %}" alt=""><span class=rvts4>, где </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00120.png' %}" alt=""> </span><span class=rvts1638>−</span><span class=rvts4> мощность множества ключей </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00121.png' %}" alt=""><span class=rvts4>. Затем подбираем случайным образом ключи </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00122.png' %}" alt=""><span class=rvts4> для расшифрования шифртекстов </span><span class=rvts51>y</span><span class=rvts4>. Результат расшифрования </span><span class=rvts51>v</span><span class=rvts4> сравниваем с базой данных, а именно с значениями </span><span class=rvts51>c</span><span class=rvts4>. Если текст </span><span class=rvts51>v</span><span class=rvts4> окажется одной из криптограмм </span><span class=rvts51>с</span><span class=rvts4>, то пара ключей </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00123.png' %}" alt=""><span class=rvts4> эквивалентна ключу </span><span class=rvts51>k</span><span class=rvts4>. Алгоритм является вероятностным и подходит не для всех алгоритмов, например алгоритм DES не подвержен взлому с использованием алгоритма встречи посередине.</span></p>
                        <p class=rvps4 style="page-break-before: always;"><span class=rvts4><br></span></p>
                        <p class=rvps4><span class=rvts4><br></span></p>
                        <p class=rvps4><span class=rvts4><br></span></p>
                        <p class=rvps4><span class=rvts4><br></span></p>
                    </div>
                </div>
            </div>
            <div class="bb-item" id="item18">
                <div class="content">
                    <div class="scroller">
                        <h2>2.2.3. Виды атак на криптографические алгоритмы</h2>
                        <p class=rvps741><span class=rvts4>Проведение криптоанализа некоторого алгоритма основывается на наличии некоторых исходных данных. В зависимостио текста (</span><span class=rvts51>known plaintext attack</span><span class=rvts4>) – криптоаналитику известны все или некоторые зашифрованные сообщения и известны (полностью или частично) соответствующие им исходные тексты. </span></p>
                        <p class=rvps741><span class=rvts1638>•</span><span class=rvts4> Атака на основе выбранного открытого текста (</span><span class=rvts51>chosen plaintext attack</span><span class=rvts4>) </span><span class=rvts1638>−</span><span class=rvts4> предполагает, что криптоаналитику доступно устройство шифрования, и он имеет возможность формировать открытый текст и получать соответствующий ему шифртекст.</span></p>
                        <p class=rvps741><span class=rvts1638>•</span><span class=rvts4> Атака на основе выбранного шифртекста (</span><span class=rvts51>chosen ciphertext attack</span><span class=rvts4>) </span><span class=rvts1638>−</span><span class=rvts4> для проведения этого вида атаки криптоаналитику должно быть доступно устройство расшифрования, которое он может использовать для обработки специальным образом сформированных шифртекстов с последующим анализом результатов. </span></p>
                        <p class=rvps741><span class=rvts1638>•</span><span class=rvts4> Атака на основе адаптированного открытого текста (</span><span class=rvts51>adaptive chosen plaintext attack</span><span class=rvts4>) </span><span class=rvts1638>−</span><span class=rvts4> предполагает возможность многократного (итеративного) использования выбранных открытых текстов для последующего шифрования с учетом результатов предыдущей итерации. </span></p>
                        <p class=rvps741><span class=rvts1638>•</span><span class=rvts4> Атака на основе адаптированного шифртекста (</span><span class=rvts51>adaptive chosen ciphertext attack</span><span class=rvts4>) </span><span class=rvts1638>−</span><span class=rvts4> предполагает возможность многократного (итеративного) использования выбранных шифртекстов для последующего расшифрования с учетом результатов предыдущей итерации. </span></p>
                        <p class=rvps741><span class=rvts1638>•</span><span class=rvts4> Атака с выбором ключа </span><span class=rvts1638>−</span><span class=rvts4> характеризуется возможностью криптоаналитика использовать для шифрования/расшифрования различные ключи с последующим анализом результатов. Собственно, для использования этого метода необходимо только знание алгоритма шифрования. </span></p>
                        <p class=rvps741><span class=rvts1638>•</span><span class=rvts4> Атака на основе преднамеренно генерируемых аппаратных ошибок.</span></p>
                        <p class=rvps741><span class=rvts1638>•</span><span class=rvts4> Атака на основе замеров потребляемой мощности.</span></p>
                        <p class=rvps741><span class=rvts1638>•</span><span class=rvts4> Атака на основе анализа времени вычислений.</span></p>
                        <p class=rvps741><span class=rvts38>Последние три вида атак </span><span class=rvts4>носят общее название "физических" (</span><span class=rvts51>physical attack</span><span class=rvts4>), и требуют наличия самого физического устройства шифрования или доступа к такому устройству (например, ведения наблюдения за интенсивностью электромагнитного излучения от устройства). </span></p>
                        <p class=rvps741><span class=rvts4>Из рассмотренного множества атак на БШ можно выделить две наиболее важны от информации, известной криптоаналитику, им могут быть предприняты следующие виды атак на блочные алгоритмы шифрования:</span></p>
                        <p class=rvps741><span class=rvts1638>•</span><span class=rvts4> Атака на основе известного шифртекста (</span><span class=rvts51>ciphertext only attack</span><span class=rvts4>) </span><span class=rvts1638>−</span><span class=rvts4> предполагает, что криптоаналитику известны все или некоторые зашифрованные сообщения, является наиболее общим (распространенным) условием для проведения атаки, а также и наименее благоприятным вариантом для атакующего.</span></p>
                        <p class=rvps741><span class=rvts1638>•</span><span class=rvts4> Атака на основе известного шифртекста и соответствующего ему открытогх. Применительно к криптоанализу это атака с известными открытыми текстами и соответствующими им шифртекстами как наиболее доступный вид материала, имеющийся в распоряжении криптоаналитика. Это наименее благоприятные условия для проведения криптоанализа. Применительно к оцениванию стойкости алгоритмов шифрования в системе сертификации и принятия к использованию в качестве стандарта наиболее важное значение имеет атака с адаптированным открытым текстом и шифртекстом, это наиболее благоприятные условия для криптоаналитика. Если алгоритм шифрования обеспечивает требуемую стойкость в этом случае, то, очевидно, что такая же или большая стойкость будет обеспечиваться и по отношению к другим разновидностям атак (кроме технических методов криптоанализа, которые требуют проведения дополнительных исследований).</span></p>
                        <p class=rvps741 style="page-break-before: always;"><span class=rvts4><br></span></p>
                        <p class=rvps116><span class=rvts10><br></span></p>
                        <p class=rvps116><span class=rvts10><br></span></p>
                    </div>
                </div>
            </div>
            <div class="bb-item" id="item19">
                <div class="content">
                    <div class="scroller">
                        <h2>2.2.4. Методы криптоанализа, использующие перебор ключей</h2>
                        <p class=rvps317><span class=rvts4>К методам криптоанализа, основанным на переборе ключей, обычно относят два метода: метод полного перебора ключей и атака по словарю.</span></p>
                        <p class=rvps317><span class=rvts166> <strong>Метод полного перебора ключей</strong> </span><span class=rvts4> заключается в том, что атакующий последовательно перебирает все возможные ключи алгоритма шифрования пока не найдет искомый. Если длина ключа алгоритма составляет </span><span class=rvts51>n</span><span class=rvts4> бит, то среднее количество ключей, которые нужно перебрать, составляет </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00124.png' %}" alt=""><span class=rvts4>. Достоинством полного перебора является его универсальность, низкая требовательность к исходным данным и возможность распараллеливания путем разделения всего пространства ключей на отдельные секторы. Основным недостатком метода полного перебора является невозможность перебора ключей современных алгоритмов из-за экспоненциального роста сложности в зависимости от длины ключа. Наиболее успешный пример применения метода полного перебора — это взлом блочного алгоритма шифрования DES.</span></p>
                        <p class=rvps317><span class=rvts4> Для успешного применения этого метода необходимо использовать некоторый критерий, который позволит отличить верный ключ от неверного. </span></p>
                        <p class=rvps317><span class=rvts4>Рассмотрим подходы к построению такого критерия.</span></p>
                        <p class=rvps595><span class=rvts31>1. Криптоаналитику известно некоторое количество данных вида открытый текст/соответствующий ему шифртекст. Это наиболее простой случай, критерием правильности ключа является соответствие открытого текста известного криптоаналитику и открытого текста, полученного путем пробного расшифрования.</span></p>
                        <p class=rvps595><span class=rvts31>2. Криптоаналитику известна косвенная информация об открытом тексте. В этом случае в качестве критерия правильности ключа необходимо использовать модели открытого текста разных порядков (от первого до четвертого) или расстояние единственности, если открытый текст </span><span class=rvts1640>−</span><span class=rvts31> это сообщение с использованием одного из разговорных алфавитов. При использовании расстояния единственности объем открытого текста, полученного при пробном расшифровании, должен превышать расстояние единственности </span></p>
                        <p class=rvps595><span class=rvts31>3. Криптоаналитику ничего не известно о шифртексте. В этом случае в качестве критерия правильности ключа можно использовать величину информационной энтропии (Шеннона), вычисленную от открытого текста, полученного при пробном расшифровании. Чем меньше эта энтропия, тем больше вероятность того, что открытый текст был получен с использованием правильного ключа.</span></p>
                        <p class=rvps317><span class=rvts4>Необходимо отметить, что варианты 2 и 3 будут неработоспособны в случае, если отрытый тест является данными, по характеристикам идентичными случайной последовательности.</span></p>
                        <p class=rvps317><span class=rvts4>Сложность использования метода полного перебора состоит в том, что объем ключей, которые необходимо перебрать, экспоненциально возрастает в зависимости от размера ключа алгоритма шифрования. Эта зависимость отражена на рис. 2.3. С учетом современного развития вычислительной техники, сегодня для полного перебора доступны ключи размером до 80 бит в зависимости от средств, затраченных на вычислительные мощности. При этом ключ должен быть равновероятной строкой бит, желательно полученной с помощью генератора случайных чисел с хорошими свойствами. Если ключ не состоит из равновероятных бит, то сложность его взлома уменьшается. Вычислить размер пространства ключей в этом случае можно в случае, если известен алфавит (набор символов) из которых составлен ключ. Для ключа(пароля) состоящего из </span><span class=rvts51>n</span><span class=rvts4> символов, принадлежащих алфавиту размерности </span><span class=rvts51>k</span><span class=rvts4> пространство ключей, будет равно </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00125.png' %}" alt=""><span class=rvts4>.</span></p>
                        <p class=rvps317><span class=rvts4>Например, пространство перебора для ключа, состоящего из 8 строчных символов английского языка равно </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00126.png' %}" alt=""><span class=rvts4> бит, а не 64, которые он занимает при хранении. Для пароля, состоящего из строчных и прописных символов, пространство ключей составляет </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00127.png' %}" alt=""><span class=rvts4> бит. </span><span class=rvts38>Гарантированно защищенным от полного перебора в настоящий момент считается ключ длиной</span><span class=rvts4> от 128 бит.</span></p>
                        <p class=rvps317><span class=rvts51><br></span></p>
                        <p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00128.png' %}" alt=""></p>
                        <p style="text-align: center;"><span class=rvts51>Рис. 2.3. Зависимость пространства перебора от размера ключа</span></p>
                        <p class=rvps317><span class=rvts51><br></span></p>
                        <p class=rvps317><span class=rvts4>Оценочная стоимость взлома ключей разной длины полным перебором приведена в табл. 2.1.</span></p>
                        <p class=rvps597><span class=rvts4><br></span></p>
                        <p style="text-align: center;"><span class=rvts51>Таблица 2.1</span></p>
                        <p class=rvps916><span class=rvts30>Сравнение условной стоимости взлома ключей различной длины</span></p>
                        <div class=rvps597><table width=623 border=1 cellpadding=4 cellspacing=-1 style="border-width: 0px; border-collapse: collapse; margin: 0px auto;">
                        <tr valign=top>
                        <td width=173 valign=middle style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps917><span class=rvts30>Субъект</span></p>
                        </td>
                        <td width=120 valign=middle style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps917><span class=rvts30>Стоимость</span></p>
                        </td>
                        <td width=123 valign=middle style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps918><span class=rvts30>Платформа</span></p>
                        </td>
                        <td width=164 valign=middle style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps918><span class=rvts30>Длина ключа (бит)</span></p>
                        </td>
                        </tr>
                        <tr valign=top>
                        <td width=173 valign=middle style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps920><span class=rvts4>Хакер</span></p>
                        </td>
                        <td width=120 valign=middle style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps597><span class=rvts4>400$</span></p>
                        </td>
                        <td width=123 valign=middle style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps597><span class=rvts4>PC/FPGA</span></p>
                        </td>
                        <td width=164 valign=middle style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps597><span class=rvts4>60</span></p>
                        </td>
                        </tr>
                        <tr valign=top>
                        <td width=173 valign=middle style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps921><span class=rvts4>Небольшая компания</span></p>
                        </td>
                        <td width=120 valign=middle style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps597><span class=rvts4>10K$</span></p>
                        </td>
                        <td width=123 valign=middle style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps597><span class=rvts4>PC/FPGA</span></p>
                        </td>
                        <td width=164 valign=middle style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps597><span class=rvts4>64</span></p>
                        </td>
                        </tr>
                        <tr valign=top>
                        <td width=173 valign=middle style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps923><span class=rvts4>Средняя компания</span></p>
                        </td>
                        <td width=120 valign=middle style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps597><span class=rvts4>300K$</span></p>
                        </td>
                        <td width=123 valign=middle style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps597><span class=rvts4>FPGA/ASIC</span></p>
                        </td>
                        <td width=164 valign=middle style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps597><span class=rvts4>68</span></p>
                        </td>
                        </tr>
                        <tr valign=top>
                        <td width=173 valign=middle style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps923><span class=rvts4>Крупная компания</span></p>
                        </td>
                        <td width=120 valign=middle style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps597><span class=rvts4>10M$</span></p>
                        </td>
                        <td width=123 valign=middle style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps597><span class=rvts4>FPGA/ASIC</span></p>
                        </td>
                        <td width=164 valign=middle style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps597><span class=rvts4>78</span></p>
                        </td>
                        </tr>
                        <tr valign=top>
                        <td width=173 valign=middle style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps926><span class=rvts4>Правительство</span></p>
                        </td>
                        <td width=120 valign=middle style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps597><span class=rvts4>300M$</span></p>
                        </td>
                        <td width=123 valign=middle style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps597><span class=rvts4>ASIC</span></p>
                        </td>
                        <td width=164 valign=middle style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps597><span class=rvts4>84</span></p>
                        </td>
                        </tr>
                        </table>
                        </div>
                        <p class=rvps317><span class=rvts4><br></span></p>
                        <p class=rvps317><span class=rvts4>Несмотря на все недостатки метод полного перебора остается актуальным, так как может быть использован на завершающей части других методов взлома.</span></p>
                        <p class=rvps317><span class=rvts4>Для защиты от полного перебора достаточно использовать ключи длиной 128 бит или более.</span></p>
                        <p class=rvps317><span class=rvts4>Второй переборный метод криптоанализа </span><span class=rvts1638>−</span><span class=rvts4> это </span><span class=rvts166>атака по словарю</span><span class=rvts4>. Для ее проведения криптоаналитик сначала формирует словарь наиболее употребительных паролей, а потом применяет последовательно все пароли из этого словаря. Эта атака в основном предназначена не для определения ключа шифрования, а для определения пароля, на основе которого этот ключ генерируется. Атака по словарю имеет меньшую сложность чем полный перебор, так как проверяет не все ключи, а только наиболее вероятные. Для защиты от этого метода необходимо выбирать пароли случайным образом и проверять их на присутствие в общедоступных словарях наиболее употребительных паролей, использовать алгоритмы проверки качества паролей.</span></p>
                        <p class=rvps317 style="page-break-before: always;"><span class=rvts4><br></span></p>
                    </div>
                </div>
            </div>
            <div class="bb-item" id="item20">
                <div class="content">
                    <div class="scroller">
                        <h2>Контрольные вопросы</h2>
                        <p>1. Что такое криптоанализ?</p>
                        <p>2. Что такое криптостойкость?</p>
                        <p>3. Назовите основные ресурсы, используемые криптоаналитиком.</p>
                        <p>4. Сформулируйте принцип Кирхгофа.</p>
                        <p>5. Назовите три основных класса методов криптоанализа.</p>
                    </div>
                </div>
            </div>
            <!-- Конец 2го раздела -->
            <!-- НАчало 3го раздела -->
            <div class="bb-item" id="item21">
                <div class="content">
                    <div class="scroller">
                        <h2>3. Современные блочные шифры и методы из криптоанализа</h2>
                        <p>3.1. Классические блочные алгоритмы шифрования. Альтернативные варианты построения блочных шифров</p>
                        <p>3.2. Примеры блочных шифров</p>
                        <p>3.3. Классификация методов криптоанализа блочных шифров</p>
                        <p>3.4. Основы дифференциального криптоанализа блочных шифров</p>
                        <p>3.5. Линейный криптоанализ блочных шифров</p>
                        <p>3.6. Интегральный и алгебраический криптоанализ блочных шифров</p>
                    </div>
                </div>
            </div>
            <div class="bb-item" id="item21">
                <div class="content">
                    <div class="scroller">
                        <h2>3.1. Классические блочные алгоритмы шифрования. Альтернативные варианты построения блочных шифров</h2>
                        <p>3.1.1. Модель итерационного блочного шифра</p>
                        <p>3.1.2. Структурные элементы блочного шифра блочного шифра  </p>
                        <p>3.1.3. Основные схемы построения блочных шифров</p>
                        <p>3.1.4. Шифры структуры подстановочно-перестановочной сети</p>
                        <p>3.1.5. Альтернативные схемы построения блочных шифров</p>
                        <p>3.1.6. Режимы применения блочных шифров </p>
                        <p>Контрольные вопросы</p>
                    </div>
                </div>
            </div>
            <div class="bb-item" id="item22">
                <div class="content">
                    <div class="scroller">
                        <h2>3.1.1. Модель итерационного блочного шифра</h2>
                        <p class=rvps952><span class=rvts4>Блочные шифры представляют собой подкласс симметричных криптографических алгоритмов – алгоритмов, использующих один и тот же ключ для шифрования и расшифрования информации. Математически блочный шифр является обратимой функцией:</span></p>
                        <p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00131.png' %}" alt=""><span class=rvts4>.</span></p>
                        <p class=rvps952><span class=rvts4>Подлежащий шифрованию текст разбивается на блоки равной длины, и каждый блок шифруется с помощью одного и того же криптопреобразования, зависящего от секретного ключа. Для повышения стойкости шифра это преобразование циклически повторяется несколько раз (итерируется). </span></p>
                        <p class=rvps952><span class=rvts4>При построении БШ используется начальное преобразование данных, однократно применяемое к входному блоку, и обратное ему конечное преобразование, преобразующее блок данных после завершения цикла шифрования. При выполнении шифрования, обычно, </span><span class=rvts38>требуется количество ключевого материала, значительно превышающее размер ключа алгоритма, поэтому в БШ применяется алгоритм расширения ключа пользователя до требуемой длины. Структурная модель</span><span class=rvts4> типового блочного шифра представлена на рис. 3.1.</span></p>
                        <p class=rvps952><span class=rvts4>Каждый из элементов в составе модели является обязательным и отсутствие любого из них говорит о слабости алгоритма шифрования.</span></p>
                        <p class=rvps952><span class=rvts39>Б</span><span class=rvts4>лочный шифр также является некоторой функцией битов шифртекста от битов открытого текста и ключа. Задачей блочного шифра является обеспечение максимальной нелинейности этой функции и зависимости каждого выходного бита от максимального числа (в современных шифрах от всех) входных бит. Для обеспечения этого раундовая функция шифра должна удовлетворять принципам рассеивания и перемешивания. Конечной целью применения данных принципов является максимальное затруднение описания шифра системой однородных уравнений (над одним полем, например, по модулю 2). </span></p>
                        <p class=rvps4><span class=rvts4><br></span></p>
                        <div class=rvps43><table border=0 cellpadding=4 cellspacing=0 style="border-width: 0px; border-spacing: 0px; margin: 0px auto;">
                        <tr valign=top>
                        <td width=610 valign=top style="padding: 0px 7px;"><p class=rvps43><span class=rvts4><br></span></p>
                        <p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00131.png' %}" alt=""></p>
                        <p class=rvps43><span class=rvts4><br></span></p>
                        </td>
                        </tr>
                        <tr valign=top>
                        <td width=610 valign=top style="padding: 0px 7px;"><p style="text-align: center;"><span class=rvts51>Рис. 3.1. Структура и основные элементы современного блочного шифра</span></p>
                        </td>
                        </tr>
                        </table>
                        </div>
                        <p class=rvps730><span class=rvts40><br></span></p>
                        <p class=rvps730><span class=rvts40><br></span></p>
                        <p class=rvps730><span class=rvts3918> <strong>Рассеивание</strong></span><span class=rvts40> </span><span class=rvts3919>−</span><span class=rvts40> </span><span class=rvts39>это свойство шифра, при котором один символ (бит) открытого текста влияет на несколько символов (битов) шифртекста, оптимально </span><span class=rvts3920>−</span><span class=rvts39> на все символы в пределах одного блока. Достигается применением нелинейного преобразования.</span></p>
                        <p class=rvps730><span class=rvts3918> <strong>Перемешивание</strong></span><span class=rvts39> </span><span class=rvts3919>−</span><span class=rvts39> это свойство блочного шифра скрывать зависимости между символами открытого текста и шифртекста.</span></p>
                        <p class=rvps730><span class=rvts4>Блочный шифр, как и любой другой криптографический примитив, должен быть нелинейным, так как в противном случае он автоматически становится неустойчивым к атаке вида «открытый текст/соответствующий ему шифртекст». Это происходит потому, что, если шифр является линейным, значит можно его описать системой линейных уравнений (далее СЛАУ) относительно переменных открытого текста, шифртекста и ключа. Подставив в эту систему значения переменных открытого текста и соответствующего ему шифртекста, мы получим СЛАУ, при решении которой будет найден ключ шифрования. Решение систем линейных уравнений большого размера (128*128 при использовании одного блока и 128 битного ключа) сегодня не представляет особой трудности. Так, например, метод Гаусса имеет сложность </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00133.png' %}" alt=""><span class=rvts4> арифметических операций, существуют методы с меньшей сложностью порядка </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00134.png' %}" alt=""><span class=rvts4>. </span></p>
                        <p class=rvps730><span class=rvts4>Таким образом, для решения СЛАУ 128*</span><span class=rvts38>128 необходимо всего </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00135.png' %}" alt=""><span class=rvts38> операций, что потребует не более</span><span class=rvts4> 10 секунд для решения и последующего взлома шифра. Совсем иначе обстоят дела с системами нелинейными уравнений. Сегодня не существует эффективных методов решения систем нелинейных уравнений такого размера. Это возможно лишь в некоторых частных случаях, например, когда уравнений гораздо больше, чем переменных, тогда можно вместо каждого нелинейного члена добавить переменную (т. е. выполнить его линеаризацию) и решить уравнение как СЛАУ. Поэтому в криптографических примитивах стараются сделать систему максимально нелинейной. Понятие нелинейности при этом несколько отличается от математического. </span></p>
                        <p class=rvps730><span class=rvts166> <strong>Нелинейность</strong> </span><span class=rvts4> </span><span class=rvts1638>−</span><span class=rvts4> это степень отличия от линейного уравнения, а не максимальная степень члена уравнения. Так, например, уравнение </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00136.png' %}" alt=""><span class=rvts4> ведет себя как нелинейное только в одном случае </span><span class=rvts38>из</span><span class=rvts1268> </span><span class=rvts649>16 возможных,</span><span class=rvts38> когда </span><span class=rvts4>все переменные равны 1. Напротив, уравнение с большим количеством нелинейных членов разных степеней </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00137.png' %}" alt=""><span class=rvts4> имеет гораздо большую нелинейность. В идеале, в составе каждого нелинейного уравнения в системе, описывающей шифр с вероятностью, должны появляться все возможные члены общей нелинейной формы булевой функции:</span></p>
                        <p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00138.png' %}" alt=""></p>
                        <p class=rvps961><span class=rvts4>и это обеспечивается в составе качественных современных блочных шифрах. </span></p>
                        <p class=rvps952><span class=rvts4>В этом случае каждое уравнение будет содержать столько членов, что его будет невозможно записать или хранить в памяти современных вычислительных устройств.</span></p>
                        <p class=rvps730><span class=rvts4>Аналогично нелинейности в составе криптографических примитивов в целом, и в блочных шифрах в частности, важное значение имеет принцип использования операций над разными конечными полями. Это также связано с нелинейностью. Все дело в том, что линейные операции в различных полях становятся нелинейными при их совместном рассмотрении. То есть, при переходе от одного поля к другому уравнение из линейного становится нелинейным. Рассмотрим простейший пример: пусть имеется две переменных </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00139.png' %}" alt=""><span class=rvts4> &nbsp;размерностью 4 бита. Для них выполняется операция сложения по модулю 4, результат записывается в переменную </span><span class=rvts51>y</span><span class=rvts4>. Эта же операция при представлении ее в поле по модулю 2 имеет следующий вид:</span></p>
                        <p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00140.png' %}" alt=""><span class=rvts3921>,</span></p>
                        <p class=rvps962><span class=rvts4>т. е. из линейной становится нелинейной. Легко представить какой размерности будет уравнение для последнего бита по переводе операции сложения по модулю </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00141.png' %}" alt=""><span class=rvts4> в поле по модулю 2. Аналогичные трудности возникают и при обратном переходе при записи сложения по модулю 2 в системе по модулю </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00142.png' %}" alt=""><span class=rvts4>. </span></p>
                        <p class=rvps730><span class=rvts4>Основными характеристиками блочного шифра являются:</span></p>
                        <p class=rvps959><span class=rvts1640>−</span><span class=rvts31> размер блока; типовыми размерами являются 64 бита, 128, 192, 256, размер блока в 64 бита в настоящее время считается недостаточным, наиболее часто используется размер 128 бит;</span></p>
                        <p class=rvps959><span class=rvts3923>−</span><span class=rvts93> размер ключа; типовыми размерами являются размеры, аналогичные размеру блока, при этом размер ключа менее 128 бит считается недостаточно защищенным;</span></p>
                        <p class=rvps959><span class=rvts1640>−</span><span class=rvts31> количество раундов; в зависимости от сложности раундовой функции может быть от 4 до 64;</span></p>
                        <p class=rvps959><span class=rvts1640>−</span><span class=rvts31> тип использованного нелинейного преобразования, линейного преобразования, ключевого расписания.</span></p>
                        <p class=rvps730><span class=rvts4>Существуют два подхода к проектированию блочных шифров. Один из них предполагает использование максимально простых и быстрых элементов в составе раундовой функции, но при этом использовании большого количества раундов. Это алгоритмы Tea, DES, ГОСТ 28147-89, Serpent, CAST-256. Второй подход предполагает использование максимально сложных элементов с хорошими характеристиками в раундовой функции, но использование небольшого числа раундов. С его применение созданы шифры AES, Anubis, Crypton.</span></p>
                        <p class=rvps730><span class=rvts4>Если размер блока должен быть безопасным для полного перебора современной техники, то необходимость большого размера блока не столь очевидна. Это связано с тем, что при уменьшении размера блока до 8</span><span class=rvts1638>−</span><span class=rvts4>16 бит блочный шифр вырождается в шифр простой замены, чем он, по сути, и является только для символов большого размера, например, 128 бит. Если размер блока блочного шифра будет равен от 8 или 16 бит, то несмотря на свою сложную внутреннюю структуру такой шифр можно взломать обычным частотным анализом, а с использованием атаки «открытый текст/шифртекст» и того быстрее. Если размер блока будет равен 24 или 32 бита, то у криптоаналитика появится возможность, накапливая статистику блоков, получать дополнительную информацию об открытом тексте.</span></p>
                        <p class=rvps730 style="page-break-before: always;"><span class=rvts4><br></span></p>
                        <p class=rvps730><span class=rvts4><br></span></p>
                    </div>
                </div>
            </div>
            <div class="bb-item" id="item23">
                <div class="content">
                    <div class="scroller">
                        <h2>3.1.2. Структурные элементы блочного шифра блочного шифра</h2>
                        <p class=rvps767><span class=rvts4>В качестве начального и конечного преобразования используются самые различные конструкции. Для алгоритма DES – это обычная перестановка бит, для алгоритма E2 – это сложение с подключом и умножение на другой подключ по модулю </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00143.png' %}" alt=""><span class=rvts4>, некоторые алгоритмы не имеют начального и конечного преобразования вообще. Сегодня считается, что операции начального и конечного преобразования не оказывают существенного влияния на криптостойкость алгоритма шифрования</span><span class=rvts38>. Тем не менее, использование зависящих от ключа нелинейных операций по модулю </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00144.png' %}" alt=""><span class=rvts38>, </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00145.png' %}" alt=""><span class=rvts38> позволит защититься от линейного и дифференциального криптоанализа, предполагающих, что можно перебрать часть ключа последнего раунда независимо от остальных частей ключа. </span></p>
                        <p class=rvps767><span class=rvts4>В качестве нелинейного преобразования используются подстановки или SBox-ы. Они задаются таблично и поэтому имеют размерность от 3 до 8 бит. Количество элементов таблицы замены определяется как </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00146.png' %}" alt=""><span class=rvts4>, где </span><span class=rvts51>n</span><span class=rvts4> </span><span class=rvts1638>−</span><span class=rvts4> размерность блока </span><span class=rvts39>подстановки. В табл. 3.1 приведет пример подстановки размерности 4 бита.</span></p>
                        <p class=rvps767><span class=rvts4><br></span></p>
                        <p class=rvps973><span class=rvts51>Таблица 3.1</span></p>
                        <p style="text-align: center;"><span class=rvts30>Пример подстановки для алгоритма ГОСТ 28147</span><span class=rvts3926>−</span><span class=rvts30>89</span></p>
                        <div class=rvps968><table width="100%" border=1 cellpadding=4 cellspacing=-1 style="border-width: 0px; border-collapse: collapse;">
                        <tr valign=top>
                        <td width="6%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps970><span class=rvts41>0</span></p>
                        </td>
                        <td width="6%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps970><span class=rvts41>1</span></p>
                        </td>
                        <td width="6%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps970><span class=rvts41>2</span></p>
                        </td>
                        <td width="6%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps970><span class=rvts41>3</span></p>
                        </td>
                        <td width="6%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps970><span class=rvts41>4</span></p>
                        </td>
                        <td width="6%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps970><span class=rvts41>5</span></p>
                        </td>
                        <td width="6%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps970><span class=rvts41>6</span></p>
                        </td>
                        <td width="6%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps970><span class=rvts41>7</span></p>
                        </td>
                        <td width="6%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps970><span class=rvts41>8</span></p>
                        </td>
                        <td width="6%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps970><span class=rvts41>9</span></p>
                        </td>
                        <td width="6%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps970><span class=rvts41>10</span></p>
                        </td>
                        <td width="6%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps970><span class=rvts41>11</span></p>
                        </td>
                        <td width="6%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps970><span class=rvts41>12</span></p>
                        </td>
                        <td width="6%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps970><span class=rvts41>13</span></p>
                        </td>
                        <td width="6%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps970><span class=rvts41>14</span></p>
                        </td>
                        <td width="6%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps970><span class=rvts41>15</span></p>
                        </td>
                        </tr>
                        <tr valign=top>
                        <td width="6%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps970><span class=rvts41>4</span></p>
                        </td>
                        <td width="6%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps970><span class=rvts41>10</span></p>
                        </td>
                        <td width="6%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps970><span class=rvts41>9</span></p>
                        </td>
                        <td width="6%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps970><span class=rvts41>2</span></p>
                        </td>
                        <td width="6%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps970><span class=rvts41>13</span></p>
                        </td>
                        <td width="6%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps970><span class=rvts41>8</span></p>
                        </td>
                        <td width="6%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps970><span class=rvts41>0</span></p>
                        </td>
                        <td width="6%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps970><span class=rvts41>14</span></p>
                        </td>
                        <td width="6%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps970><span class=rvts41>6</span></p>
                        </td>
                        <td width="6%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps970><span class=rvts41>11</span></p>
                        </td>
                        <td width="6%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps970><span class=rvts41>1</span></p>
                        </td>
                        <td width="6%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps970><span class=rvts41>12</span></p>
                        </td>
                        <td width="6%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps970><span class=rvts41>7</span></p>
                        </td>
                        <td width="6%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps970><span class=rvts41>15</span></p>
                        </td>
                        <td width="6%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps970><span class=rvts41>5</span></p>
                        </td>
                        <td width="6%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps970><span class=rvts41>3</span></p>
                        </td>
                        </tr>
                        </table>
                        </div>
                        <p class=rvps767><span class=rvts4><br></span></p>
                        <p class=rvps767><span class=rvts4>Так как размерность нелинейного преобразования почти всегда меньше размера блока, то используется слой параллельных подстановок. К выбору нелинейного преобразования необходимо подходить особенно тщательно, так как это обычно единственный нелинейный элемент системы. Он имеет ключевую роль в обеспечении криптостойкости блочного шифра. Лучшую стойкость имеет схема, где используются подстановки большого размера. Подстановки бывают биективные (обратимые) и небиективные, также они могут иметь разные размерности входа и выхода. Существуют, также, подстановки с оптимальными характеристиками. Это подстановки, сгенерированные с помощью операции взятия обратного элемента в поле по модулю неприводимого полинома.</span></p>
                        <p class=rvps767><span class=rvts4>Линейное преобразование предназначено для перемешивания данных между различными блоками нелинейного преобразования, чтобы отдельные блоки текста не являлись независимыми друг от друга. В качестве простейшего линейного преобразования используется перестановка бит, более сложные линейные преобразования выполняются в некотором векторном пространстве над различными конечными полями. В случае отсутствия линейной операции блочный шифр вырождается в несколько независимых шифров малой (по размеру используемой подстановки) размерности (рис. 3.2), которые легко можно вскрыть частотным анализом.</span></p>
                        <p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00147.png' %}" alt=""></p>
                        <p class=rvps969><span class=rvts51>Рис. 3.2. Визуализация действия этапа линейного преобразования в блочном шифре</span></p>
                        <p class=rvps767><span class=rvts4><br></span></p>
                        <p class=rvps767><span class=rvts4>Для операции добавления подключа обычно используется операция сложения по модулю 2. Можно также использовать операцию сложения/вычитания и любую другую пару обратимых операций.</span></p>
                        <p class=rvps767 style="page-break-before: always;"><span class=rvts4><br></span></p>
                        <p class=rvps767><span class=rvts4><br></span></p>
                    </div>
                </div>
            </div>
            <div class="bb-item" id="item24">
                <div class="content">
                    <div class="scroller">
                        <h2>3.1.3. Основные схемы построения блочных шифров</h2>
                        <p class=rvps715><span class=rvts4>Шифры классической сети Фейстеля имеют структуру раундовой функции, представленную на рис. 3.3. В классической сети Фейстеля исходный блок данных делится на две половины, одна из которых преобразуется некоторой функцией шифрования </span><span class=rvts51>F</span><span class=rvts4> с ключом текущей итерации, а затем поразрядно складывается с другой половиной блока, после чего результат и исходная половина блока меняются местами. </span></p>
                        <p class=rvps4><span class=rvts4><br></span></p>
                        <div class=rvps43><table border=0 cellpadding=4 cellspacing=0 style="border-width: 0px; border-spacing: 0px; margin: 0px auto;">
                        <tr valign=top>
                        <td width=384 valign=top style="padding: 0px 7px;"><p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00148.png' %}" alt=""></p>
                        </td>
                        </tr>
                        <tr valign=top>
                        <td width=384 valign=top style="padding: 0px 7px;"><p style="text-align: center;"><span class=rvts51>Рис. 3.3. Схема классической сети Фейстеля</span></p>
                        <p class=rvps43><span class=rvts4><br></span></p>
                        </td>
                        </tr>
                        </table>
                        </div>
                        <p class=rvps741><span class=rvts4>Данная структура обладает рядом достоинств:</span></p>
                        <p class=rvps979><span class=rvts1640>−</span><span class=rvts31> процедуры шифрования и расшифрования совпадают, поэтому упрощается программная реализация алгоритма и снижается стоимость аппаратной реализации;</span></p>
                        <p class=rvps979><span class=rvts1640>−</span><span class=rvts31> функция </span><span class=rvts1637>F</span><span class=rvts31> не должна быть биективной (обратимой), что существенно расширяет возможности по ее построению. Это объясняется тем, что при проведении обратного преобразования используется та же функция </span><span class=rvts1637>F</span><span class=rvts31>, а не обратная ей, т. е. операции шифрования и расшифрования отличаются только порядком использования ключевых элементов.</span></p>
                        <p class=rvps980><span class=rvts4>Недостатком сетей </span><a class=rvts65 href="1430.html"  OnClick="javascript:NewWindow=window.open('1430.html','NewWindow','width=700,height=700,menubar=no,scrollbars');return false;">Фейстеля</a><span class=rvts4> является то, что на каждой итерации изменяется только половина блока обрабатываемого текста, а это приводит к необходимости увеличивать число итераций, для достижения требуемой стойкости. В соответствии с классической сетью Фейстеля реализованы алгоритмы DEAL, DFC, E2, LOKI97, MAGENTA, TWOFISH.</span></p>
                        <p class=rvps980><span class=rvts4>Фактически классическая сеть Фейстеля представляет собой дополнительное линейное преобразование одной половины блока, зависящее от значения нелинейной функции от второй половины блока, поэтому сеть Фейстеля формально можно отнести к классу управляемых преобразований.</span></p>
                        <p class=rvps980><span class=rvts4>К "модифицированной сети Фейстеля" относятся структурно аналогичные БШ, обрабатывающие более двух блоков одинаковой длины (рис. 3.4).</span></p>
                        <p class=rvps981><span class=rvts4><br></span></p>
                        <div class=rvps43><table border=0 cellpadding=4 cellspacing=0 style="border-width: 0px; border-spacing: 0px; margin: 0px auto;">
                        <tr valign=top>
                        <td width=643 valign=top style="padding: 0px 7px;"><p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00149.png' %}" alt=""></p>
                        </td>
                        </tr>
                        <tr valign=top>
                        <td width=643 valign=top style="padding: 0px 7px;"><p style="text-align: center;"><span class=rvts51>Рис. 3.4. Схема модифицированной сети Фейстеля</span></p>
                        <p class=rvps43><span class=rvts4><br></span></p>
                        </td>
                        </tr>
                        </table>
                        </div>
                        <p class=rvps4><span class=rvts4><br></span></p>
                        <p class=rvps767><span class=rvts4>Появление таких конструктивных решений объясняется тем, что в современных алгоритмах при использовании блоков большого размера становится неудобно манипулировать подблоками большой длины, эта же проблема возникает при проектировании аппаратных устройств на микропроцессорах малой разрядности. Наибольшее распространение получила сеть Фейстеля с четырьмя ветвями и ее варианты, в </span><span class=rvts38>которой 128-битный входной блок разделяется на четыре 32-битных числа, операции</span><span class=rvts4> с которыми есть в любой микропроцессорной системе. </span></p>
                        <p class=rvps4 style="page-break-before: always;"><span class=rvts4><br></span></p>
                    </div>
                </div>
            </div>
            <div class="bb-item" id="item25">
                <div class="content">
                    <div class="scroller">
                        <h2>3.1.4. Шифры структуры подстановочно-перестановочной сети</h2>
                        <p class=rvps952><span class=rvts4>Второй распространенной схемой построения БШ является подстановочно-перестановочная сеть (SPN – </span><span class=rvts51>substitution permutation network</span><span class=rvts4>), еще называемая структурой «квадрат». Раундовая функция шифров структуры квадрат различна для операций шифрования и расшифрования, и представлена на рис. 3.5.</span></p>
                        <p class=rvps4><span class=rvts4><br></span></p>
                        <p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00150.png' %}" alt=""></p>
                        <p style="text-align: center;"><span class=rvts34>Рис. 3.5. Схема одного раунда (архитектура Square)</span></p>
                        <p class=rvps22><span class=rvts4><br></span></p>
                        <p class=rvps800><span class=rvts4>Преимуществом данной схемы является то, что на каждом шаге изменяется весь блок данных, т. е. для такой схемы требуется вдвое меньше раундов, чем для аналогичной сети Фейстеля, и такие алгоритмы имеют большее быстродействие. К шифрам этой группы принадлежат CRYPTON, Rijndael, SAFER+, SAFER++, SERPENT. </span></p>
                        <p class=rvps800><span class=rvts38>К недостаткам данной схемы относится необходимость</span><span class=rvts4> использования в ней только биективных операций, т. е. имеющих обратную операцию. Также недостатком является различие операций шифрования/расшифрования, что усложняет программную и аппаратную реализацию.</span></p>
                        <p class=rvps4 style="page-break-before: always;"><span class=rvts4><br></span></p>
                        <p class=rvps4><span class=rvts4><br></span></p>
                    </div>
                </div>
            </div>
            <div class="bb-item" id="item26">
                <div class="content">
                    <div class="scroller">
                        <h2>3.1.5. Альтернативные схемы построения блочных шифров</h2>
                        <p class=rvps715><span class=rvts4>Кроме алгоритмов шифрования классической структуры существует ряд алгоритмов шифрования с альтернативными структурами. К таким алгоритмам относятся шифры FROG, HPC и некоторые другие. С одной стороны, исследование стойкости данных алгоритмов является более сложным, так как к ним неприменимы классические методы криптоанализа блочных шифров, с другой стороны, их поведение недостаточно изучено для уверенности в их стойкости. К алгоритмам неклассической структуры относятся алгоритмы с использованием управляемых операций, т. е. блочные шифры, структура которых зависит от обрабатываемых данных. В качестве примера блочного шифра неклассической конструкции рассмотрим алгоритм «FROG».</span></p>
                        <p class=rvps715><span class=rvts4>Алгоритм FROG состоит из 8 раундов </span><span class=rvts38>преобразования, каждое из которых</span><span class=rvts4> использует случайную подстановку размерности 8 бит и два псевдослучайных буфера (XORbuf и bombPerm) размером 256 байт, которые генерируются с использованием ключа алгоритма шифрования. На подстановку накладываются некоторые ограничения, например, отсутствие циклов. Особенностью этого шифра является побайтная обработка блока данных и, таким образом, алгоритм легко может быть адаптирован для блока произвольной длины. Структура раундовой функции приведена на рис. 3.6. Алгоритм является байтовым, т. е. обрабатывает за один раз по одному байту. Также алгоритм использует случайную подстановку размерности 8 бит, и два буфера размером 256 байт, имеющих специальное заполнение. Вырожденные случаи случайного заполнения выявляются и отсеиваются на этапе инициализации шифра. Очередной байт открытого текста складывается по модулю 2 с первым буфером, результат пропускается через подстановку и записывается на место исходного байта. Дополнительно байт, следующий за текущим, и байт в позиции второго буфера по адресу, который равен значению текущего зашифрованного байта, модифицируются с помощью операции сложения по модулю 2 с значением текущего зашифрованного байта.</span></p>
                        <p class=rvps715><span class=rvts4><br></span></p>
                        <div class=rvps43><table border=0 cellpadding=4 cellspacing=0 style="border-width: 0px; border-spacing: 0px; margin: 0px auto;">
                        <tr valign=top>
                        <td width=643 valign=top style="padding: 0px 7px;"><p class=rvps43><img style="vertical-align: middle;" src="{% static 'project/images/img_00151.png' %}" alt=""></p>
                        </td>
                        </tr>
                        <tr valign=top>
                        <td width=643 valign=top style="padding: 0px 7px;"><p style="text-align: center;"><span class=rvts51>Рис. 3.6. Структура раундовой функции алгоритма FROG</span></p>
                        </td>
                        </tr>
                        </table>
                        </div>
                        <p class=rvps4><span class=rvts4><br></span></p>
                        <p class=rvps741><span class=rvts4>Создатели алгоритма утверждают, что уже после трех раундов устраняется любая статистическая избыточность исходных данных, поэтому после восьми итераций данные будут гарантированно рандомизироваными. Достоинствами алгоритма являются высокая скорость работы, в 2 раза выше AES, возможность использования любой длины блока и ключа без увеличения вычислительной сложности, использование только простых операций.</span></p>
                        <p class=rvps4 style="page-break-before: always;"><span class=rvts4><br></span></p>
                    </div>
                </div>
            </div>

            <div class="bb-item" id="item27">
                <div class="content">
                    <div class="scroller">
                        <h2>3.1.6. Режимы применения блочных шифров</h2>
                        <p class=rvps317><span class=rvts4>Блочные шифры могут использоваться различными способами для получения шифртекста с разными свойствами. Основными из них являются:</span></p>
                        <p class=rvps595><span class=rvts1636>−</span><span class=rvts31> возможность распараллеливания;</span></p>
                        <p class=rvps595><span class=rvts1640>−</span><span class=rvts31> скрытие структуры исходного текста (если структура не скрывается, одинаковые входные блоки преобразуются в одинаковые выходные, что дает аналитику некоторую информацию о природе текста);</span></p>
                        <p class=rvps595><span class=rvts1640>−</span><span class=rvts31> возможность/невозможность скрытой манипуляции блоками (в некоторых режимах можно переставить местами несколько блоков шифртекста и это не будет заметно после расшифрования);</span></p>
                        <p class=rvps595><span class=rvts1640>−</span><span class=rvts31> распространение ошибок (в некоторых режимах ошибка вызывает искажение не только в текущем блоке, но и в одном или нескольких следующих);</span></p>
                        <p class=rvps595><span class=rvts1640>−</span><span class=rvts31> возможность предвычислений.</span></p>
                        <p class=rvps317><span class=rvts4>Наиболее </span><span class=rvts39>простой</span><span class=rvts4> режим – это электронная кодовая книга (ECB) (рис. 3.7). В этом режиме открытый текст разбивается на блоки и каждый блок шифруется одним и тем же ключом. Если длина открытого текста некратна длине блока, то недостающая часть заполняется нулями с добавлением в последних байтах реальной длины открытого текста.</span></p>
                        <p class=rvps4><span class=rvts4><br></span></p>
                        <div class=rvps43><table border=0 cellpadding=4 cellspacing=0 style="border-width: 0px; border-spacing: 0px; margin: 0px auto;">
                        <tr valign=top>
                        <td width=628 valign=top style="padding: 0px 7px;"><p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00152.png' %}" alt=""></p>
                        </td>
                        </tr>
                        <tr valign=top>
                        <td width=628 valign=top style="padding: 0px 7px;"><p style="text-align: center;"><span class=rvts51>Рис. 3.7. Схема преобразования блоков открытого текста в режиме ECB</span></p>
                        </td>
                        </tr>
                        </table>
                        </div>
                        <p class=rvps4><span class=rvts30><br></span></p>
                        <p class=rvps171><span class=rvts30> <strong>Преимущества:</strong> </span><span class=rvts4> обладает высокой скоростью, имеет возможность распараллеливания, не распространяет ошибок, не имеет предвычислений.</span></p>
                        <p class=rvps171><span class=rvts30> <strong>Недостатки:</strong> </span><span class=rvts4> не скрывает структуру данных, дает манипулировать блоками, не имеет предвычислений.</span></p>
                        <p class=rvps171><span class=rvts4>Режим сцепления блоков (CBC) представлен на рис. 3.8. В этом режиме открытый текст перед шифрованием складывается по модулю 2 с предыдущим блоком шифртекста. Первый открытый текст складывается со случайным начальным вектором. Начальный вектор не является секретом и передается вместе с шифртекстом в открытом виде. </span></p>
                        <p class=rvps4><span class=rvts4><br></span></p>
                        <div class=rvps43><table border=0 cellpadding=4 cellspacing=0 style="border-width: 0px; border-spacing: 0px; margin: 0px auto;">
                        <tr valign=top>
                        <td width=628 valign=top style="padding: 0px 7px;"><p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00153.png' %}" alt=""></p>
                        </td>
                        </tr>
                        <tr valign=top>
                        <td width=628 valign=top style="padding: 0px 7px;"><p style="text-align: center;"><span class=rvts51>Рис. 3.8. Схема преобразования блоков открытого текста в режиме CBC</span></p>
                        </td>
                        </tr>
                        </table>
                        </div>
                        <p class=rvps22><span class=rvts30><br></span></p>
                        <p class=rvps952><span class=rvts30><strong>Преимущества:</strong></span><span class=rvts4> скрывает структуру данных, не дает манипулировать блоками.</span></p>
                        <p class=rvps952><span class=rvts30><strong>Недостатки:</strong></span><span class=rvts4> не имеет возможности распараллеливания, распространяет ошибку на один блок вперед, не имеет предвычислений.</span></p>
                        <p class=rvps952><span class=rvts4>Режим обратной связи по шифртексту (CFB) представлен на рис. 3.9.</span></p>
                        <p class=rvps952><span class=rvts4><br></span></p>
                        <div class=rvps43><table border=0 cellpadding=4 cellspacing=0 style="border-width: 0px; border-spacing: 0px; margin: 0px auto;">
                        <tr valign=top>
                        <td width=628 valign=top style="padding: 0px 7px;"><p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00154.png' %}" alt=""></p>
                        </td>
                        </tr>
                        <tr valign=top>
                        <td width=628 valign=top style="padding: 0px 7px;"><p style="text-align: center;"><span class=rvts51>Рис. 3.9. Схема преобразования блоков открытого текста в режиме CFB</span></p>
                        </td>
                        </tr>
                        </table>
                        </div>
                        <p class=rvps4><span class=rvts4> </span></p>
                        <p class=rvps767><span class=rvts4>Этот режим соответствует режиму гаммирования с обратной связью алгоритма ГОСТ 28147</span><span class=rvts1638>−</span><span class=rvts4>89. В этом режиме блочный шифр соответствует самосинхронизирующемуся поточному шифру.</span></p>
                        <p class=rvps767><span class=rvts30><strong>Преимущества:</strong></span><span class=rvts4> скрывает структуру данных, не дает манипулировать блоками.</span></p>
                        <p class=rvps767><span class=rvts30><strong>Недостатки:</strong></span><span class=rvts4> не имеет возможности распараллеливания, распространяет ошибку на все блоки перед сбойным вперед, не имеет предвычислений.</span></p>
                        <p class=rvps767><span class=rvts4>На рис. 3.10 представлен режим обратной связи по выходу (OFB). В этом режиме блочный шифр работает как генератор гаммы, не зависящей от открытого или шифртекста. Шифрование выполняется путем сложения гаммы с открытым текстом по модулю 2. Этот режим является чувствительным к ошибкам вида вставка/пропуск. При появлении такой ошибки весь последующий шифртекст будет расшифрован неверно. Так как гамма не зависит от открытого или шифртекста, то возможно ее вычисление заранее. </span><span class=rvts38>Это позволяет достигнуть максимально возможной скорости шифрования, состоящего из одной операции сложения по модулю 2.</span></p>
                        <p class=rvps4><span class=rvts4><br></span></p>
                        <div class=rvps43><table border=0 cellpadding=4 cellspacing=0 style="border-width: 0px; border-spacing: 0px; margin: 0px auto;">
                        <tr valign=top>
                        <td width=662 valign=top style="padding: 0px 7px;"><p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00155.png' %}" alt=""></p>
                        </td>
                        </tr>
                        <tr valign=top>
                        <td width=662 valign=top style="padding: 0px 7px;"><p style="text-align: center;"><span class=rvts51>Рис. 3.10. Схема преобразования блоков открытого текста в режиме OFB</span></p>
                        </td>
                        </tr>
                        </table>
                        </div>
                        <p class=rvps4><span class=rvts30><br></span></p>
                        <p class=rvps317><span class=rvts30><strong>Преимущества:</strong></span><span class=rvts4> скрывает структуру данных, не дает манипулировать блоками, допускает возможность предвычислений, не распространяет ошибку.</span></p>
                        <p class=rvps317><span class=rvts30><strong>Недостатки:</strong></span><span class=rvts4> не имеет возможности распараллеливания.</span></p>
                        <p class=rvps317><span class=rvts4>Режим счетчика (CTR (CounTeR)) представлен на рис. 3.11. В этом режиме выполняется операция шифрования начального вектора увеличенного на номер блока, результат шифрования складывается по модулю 2 с открытым текстом для получения шифртекста.</span></p>
                        <div class=rvps43><table border=0 cellpadding=4 cellspacing=0 style="border-width: 0px; border-spacing: 0px; margin: 0px auto;">
                        <tr valign=top>
                        <td width=661 valign=top style="padding: 0px 7px;"><p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00156.png' %}" alt=""></p>
                        </td>
                        </tr>
                        <tr valign=top>
                        <td width=661 valign=top style="padding: 0px 7px;"><p style="text-align: center;"><span class=rvts51>Рис. 3.11. Схема преобразования блоков открытого текста в режиме CTR</span></p>
                        </td>
                        </tr>
                        </table>
                        </div>
                        <p class=rvps4><span class=rvts30><br></span></p>
                        <p class=rvps317><span class=rvts30><strong>Преимущества:</strong></span><span class=rvts4> скрывает структуру данных, не дает манипулировать блоками, имеет возможность распараллеливания, не распространяет ошибку.</span></p>
                        <p class=rvps317><span class=rvts30><strong>Недостатки:</strong></span><span class=rvts4> не допускает возможности предвычислений.</span></p>
                        <p class=rvps317><span class=rvts4>Также этот режим позволяет организовать random access, т. е. расшифровать или зашифровать произвольный блок.</span></p>
                        <p class=rvps317><span class=rvts4>Различные режимы шифрования следует применять осмысленно. Например, для шифрования данных близких к случайным, таких как ключи шифрования, предварительно сжатые данные и т.п., могут быть зашифрованы в режиме ECB. Если данные являются файлом стандартного формата (doc, pdf и т.&nbsp;д.), то следует использовать режим, скрывающий структуру данных, например, CBC. Пример правильного и неправильного выбора режима шифрования приведен на рис. 3.12. На нем видно, что шифрование в режиме ECB не полностью скрывает информацию об открытом тексте, так как на рисунке видны контуры изображения и надпись.</span></p>
                        <p class=rvps4><span class=rvts38><br></span></p>
                        <div class=rvps43><table width=663 border=0 cellpadding=4 cellspacing=0 style="border-width: 0px; border-spacing: 0px; margin: 0px auto;">
                        <tr valign=top>
                        <td width=186 valign=top style="padding: 4px;"><p style="text-align: center;"><img width=115 height=115 style="vertical-align: middle;" src="{% static 'project/images/img_00157.png' %}" alt=""></p>
                        <p class=rvps43><span class=rvts42>исходное изображение</span></p>
                        <p style="text-align: center;"><span class=rvts4><br></span></p>
                        </td>
                        <td width=226 valign=top style="padding: 4px;"><p style="text-align: center;"><img width=115 height=115 style="vertical-align: middle;" src="{% static 'project/images/img_00158.png' %}" alt=""></p>
                        <p class=rvps43><span class=rvts42>шифрование в режиме ECB</span></p>
                        <p style="text-align: center;"><span class=rvts4><br></span></p>
                        </td>
                        <td width=237 valign=top style="padding: 4px;"><p style="text-align: center;"><img width=115 height=115 style="vertical-align: middle;" src="{% static 'project/images/img_00159.png' %}" alt=""></p>
                        <p style="text-align: center;"><span class=rvts42>шифрование в режиме CBC</span></p>
                        <p class=rvps43><span class=rvts4><br></span></p>
                        </td>
                        </tr>
                        </table>
                        </div>
                        <p style="text-align: center;"><span class=rvts95>Рис. 3.12. Пример шифрования изображения в режиме ECB и CBC</span></p>
                        <p class=rvps871><span class=rvts51><br></span></p>
                        <p class=rvps4><span class=rvts4>Кроме рассмотренных существуют и другие режимы со своими уникальными свойствами, мы же рассмотрели наиболее известные и широко распространенные из всех режимов.</span></p>
                        <p class=rvps4 style="page-break-before: always;"><span class=rvts4><br></span></p>
                        <p class=rvps4><span class=rvts4><br></span></p>
                        <p class=rvps4><span class=rvts4><br></span></p>
                    </div>
                </div>
            </div>
            <div class="bb-item" id="item28">
                <div class="content">
                    <div class="scroller">
                        <h2>Контрольные вопросы</h2>
                        <p>1. Что такое перемешивание и рассеивание, почему БШ обязательно должны содержать нелинейные элементы?</p>
                        <p>2. Почему нельзя использовать подстановки большой размерности?</p>
                        <p>3. Что будет, если в шифре отсутствует линейное преобразование?</p>
                        <p>4. Назвать основные варианты построения блочных шифров.</p>
                        <p>5. В чем опасность использования альтернативных вариантов построения блочных шифров?</p>
                        <p>6. Назвать основные режимы применения БШ.</p>
                    </div>
                </div>
            </div>
            <div class="bb-item" id="item29">
                <div class="content">
                    <div class="scroller">
                        <h2>3.2. Примеры блочных шифров</h2>
                        <p class=rvps576><span class=rvts4>Всего существуют десятки различных блочных шифров, и их количество постоянно увеличивается. Большой объем материала не позволяет ознакомиться со всеми из них, поэтому рассмотрим только несколько наиболее типичных примеров, алгоритм DES, AES и ГОСТ. Тем не менее, можно самостоятельно ознакомиться с большинством из существующих блочных шифров в справочнике по блочным шифрам [</span><a class=rvts228 href="/book/2/">22</a><span class=rvts4>]. Из интернет изданий следует отметить сайт </span><a class=rvts43 href="http://eprint.iacr.org/">http://eprint.iacr.org</a><span class=rvts44> </span><span class=rvts4>на котором публикуются практически все открытые статьи криптографической тематики, которые выходят во всем мире, в том числе и спецификации новых блочных шифров. </span></p>
                        <p class=rvps576><span class=rvts4>Спецификация </span><span class=rvts1638>−</span><span class=rvts4> это основной документ описывающий блочный шифр, он выпускается командой разработчиков и, как правило, содержит детальное описание алгоритма с пояснением принципов его проектирования, а также результаты предварительного тестирования БШ и оценки его криптостойкости. Часто спецификации содержат пример реализации БШ на одном из языков программирования и контрольный пример шифрования тестового вектора.</span></p>
                        <p class=rvps576></p>
                        <p class=rvps576>3.2.1. Блочный шифр DES</p>
                        <p class=rvps576>3.2.2. Блочный шифр ГОСТ</p>
                        <p class=rvps576>3.2.3. Блочный шифр Rijndael (AES)</p>
                        <p class=rvps576>3.2.4. Блочный шифр ГОСТ Р 34.12-2015 «Кузнечик»</p>
                        <p class=rvps576>3.2.5. Блочный шифр RC6</p>
                        <p class=rvps576>3.2.6. Блочный шифр Serpent</p>
                        <p class=rvps576>3.2.7. Блочный шифр Twofish</p>
                        <p class=rvps576>3.2.8. Блочный шифр MARS</p>
                        <p class=rvps576>Контрольные вопросы</p>
                        <p class=rvps576><span class=rvts4><br></span></p>
                        <p class=rvps576 style="page-break-before: always;"><span class=rvts4><br></span></p>
                    </div>
                </div>
            </div>
            <div class="bb-item" id="item30">
                <div class="content">
                    <div class="scroller">
                        <h2>3.2.1. Блочный шифр DES</h2>
                        <p class=rvps741><span class=rvts4>Исторически, DES был первым блочным шифром, опубликованным в открытой печати, он появился в 1978 году и являлся революционным для своего времени. Этот шифр имеет среднюю скорость программной и высокую скорость аппаратной реализации, которая доходит до нескольких мегабайт в секунду. Длительное время этот алгоритм являлся американским стандартом шифрования, пока не был заменен алгоритмом AES в 2000 году вследствие малой длины ключа. </span></p>
                        <div class=rvps43><table border=0 cellpadding=4 cellspacing=0 style="border-width: 0px; border-spacing: 0px; margin: 0px auto;">
                        <tr valign=top>
                        <td width=628 valign=top style="padding: 0px 7px;"><p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00161.png' %}" alt=""></p>
                        </td>
                        </tr>
                        <tr valign=top>
                        <td width=628 valign=top style="padding: 0px 7px;"><p style="text-align: center;"><span class=rvts51>Рис. 3.13. Структура блочного шифра DES</span></p>
                        </td>
                        </tr>
                        </table>
                        </div>
                        <p class=rvps314><span class=rvts4><br></span></p>
                        <p class=rvps767><span class=rvts4>Блочный шифр DES (рис. 3.13) имеет следующие характеристики:</span></p>
                        <p class=rvps1004><span class=rvts31>1) структура: классическая сеть Фейстеля;</span></p>
                        <p class=rvps1004><span class=rvts31>2) размер ключа: 56 бит;</span></p>
                        <p class=rvps1004><span class=rvts31>3) размер блока: 64 бита;</span></p>
                        <p class=rvps1004><span class=rvts31>4) количество раундов: 16.</span></p>
                        <p class=rvps767><span class=rvts4>Особенностью блочного шифра DES является широкое применение битовой перестановки</span><span class=rvts38> или «проволочной коммутацией» в терминах</span><span class=rvts4> спецификации. Эта операция очень быстро выполняется аппаратно, но при этом очень неудобна для программной реализации. Это связано с тем, что в современных процессорах и контроллерах нет операций битовой перестановки, а все попытки их разработать не увенчались успехом. Это теоретически невозможно, потому что даже для значений небольшой разрядности количество перестановок очень велико, и определяется функцией факториала от размерности данных в битах. Это означает, что такую операцию невозможно реализовать одной командой, поэтому приходится выполнять перестановку по одному биту. </span></p>
                        <p class=rvps767><span class=rvts4>Начальная перестановка алгоритма DES представлена в табл. 3.2, т. е. первый бит становится 58-м, 2-й 50-м и т. д. В качестве конечной перестановки используется перестановка обратная начальной.</span></p>
                        <p class=rvps23><span class=rvts4><br></span></p>
                        <p class=rvps1006><span class=rvts51><br></span></p>
                        <p class=rvps22><span class=rvts30><br></span></p>
                        <div class=rvps43><table width=650 border=1 cellpadding=4 cellspacing=-1 style="border-width: 0px; border-collapse: collapse; margin: 0px auto;">
                        <tr valign=top>
                        <td colspan=16 width=392 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px; border-top: none; border-right: none; border-bottom: none; border-left: none;"><p class=rvps1005><span class=rvts51>Таблица 3.2</span></p>
                        </td>
                        </tr>
                        <tr valign=top>
                        <td colspan=16 width=392 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px; border-top: none; border-right: none; border-left: none;"><p style="text-align: center;"><span class=rvts30>Начальная битовая перестановка алгоритма DES</span></p>
                        </td>
                        </tr>
                        <tr valign=top>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>58</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>50</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>42</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>34</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>26</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>18</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>10</span></p>
                        </td>
                        <td width=10 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>2</span></p>
                        </td>
                        <td width=29 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>60</span></p>
                        </td>
                        <td width=24 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>52</span></p>
                        </td>
                        <td width=27 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>44</span></p>
                        </td>
                        <td width=27 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>36</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>28</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>20</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>12</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>4</span></p>
                        </td>
                        </tr>
                        <tr valign=top>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>62</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>54</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>46</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>38</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>30</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>22</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>14</span></p>
                        </td>
                        <td width=10 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>6</span></p>
                        </td>
                        <td width=29 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>64</span></p>
                        </td>
                        <td width=24 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>56</span></p>
                        </td>
                        <td width=27 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>48</span></p>
                        </td>
                        <td width=27 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>40</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>32</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>24</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>16</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>8</span></p>
                        </td>
                        </tr>
                        <tr valign=top>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>57</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>49</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>41</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>33</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>25</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>17</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>9</span></p>
                        </td>
                        <td width=10 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>1</span></p>
                        </td>
                        <td width=29 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>59</span></p>
                        </td>
                        <td width=24 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>51</span></p>
                        </td>
                        <td width=27 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>43</span></p>
                        </td>
                        <td width=27 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>35</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>27</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>19</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>11</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>3</span></p>
                        </td>
                        </tr>
                        <tr valign=top>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>61</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>53</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>45</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>37</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>29</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>21</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>13</span></p>
                        </td>
                        <td width=10 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>5</span></p>
                        </td>
                        <td width=29 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>63</span></p>
                        </td>
                        <td width=24 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>55</span></p>
                        </td>
                        <td width=27 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>47</span></p>
                        </td>
                        <td width=27 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>39</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>31</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>23</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>15</span></p>
                        </td>
                        <td width=25 height=17 valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 4px;"><p class=rvps781><span class=rvts41>7</span></p>
                        </td>
                        </tr>
                        </table>
                        </div>
                        <p class=rvps4><span class=rvts4><br></span></p>
                        <p class=rvps767><span class=rvts4>Структура раундовой функции алгоритма DES полностью соответствует классической сети Фейстеля (рис. 3.14):</span></p>
                        <p class=rvps595><span class=rvts1640>−</span><span class=rvts31> первой операцией в ней является расширение блока до 48 бит путем копирования крайних бит в каждом блоке из 4 бит, как показано в верхней части</span><span class=rvts93> рис. 3.14;</span></p>
                        <p class=rvps595><span class=rvts3923>−</span><span class=rvts93> далее, получившиеся 48 разрядов суммируются с раундовым ключом (размер 48 бит);</span></p>
                        <p class=rvps595><span class=rvts3923>−</span><span class=rvts93> каждый блок из 6 символов заменяется на блок из 4 символов с использованием 8 различных блоков подстановок; подстановки имеют 46 входных и 4 выходных бита, т.е не являются обратимыми;</span></p>
                        <p class=rvps595><span class=rvts3923>−</span><span class=rvts93> выполняется перестановка битов получившегося блока в 32 бита в соответствии с табл. 3.2, по-видимому, эта перестановка является случайной, так как какие-либо закономерности в ней отсутствуют.</span></p>
                        <p class=rvps595><span class=rvts93><br></span></p>
                        <div class=rvps43><table border=0 cellpadding=4 cellspacing=0 style="border-width: 0px; border-spacing: 0px; margin: 0px auto;">
                        <tr valign=top>
                        <td width=628 valign=top style="padding: 0px 7px;"><p class=rvps43><img style="vertical-align: middle;" src="{% static 'project/images/img_00162.png' %}" alt=""></p>
                        </td>
                        </tr>
                        <tr valign=top>
                        <td width=628 valign=top style="padding: 0px 7px;"><p style="text-align: center;"><span class=rvts51>Рис. 3.14. Операции, составляющие раундовую функцию алгоритма DES</span></p>
                        <p class=rvps1002><span class=rvts51><br></span></p>
                        </td>
                        </tr>
                        </table>
                        </div>
                        <p class=rvps767><span class=rvts4><br></span></p>
                        <p class=rvps317><span class=rvts4>В данном алгоритме нетрадиционным решением является использование небиективных операций подстановки, имеющих вход 6 бит, а выход 4 бита.</span></p>
                        <p class=rvps317><span class=rvts4>Входной </span><span class=rvts38>56-битный</span><span class=rvts4> ключ используется для генерации 16 раундовых 48-битных ключей с помощью следующего алгоритма расширения ключа:</span></p>
                        <p class=rvps595><span class=rvts1640>−</span><span class=rvts31> производится разделение 56-битного блока на две части и по 28 бит;</span></p>
                        <p class=rvps595><span class=rvts1640>−</span><span class=rvts31> производится циклический сдвиг блоков влево на s[i] разрядов для получения блоков, значения s[i] приведены в табл. 3.3;</span></p>
                        <p class=rvps595><span class=rvts1640>−</span><span class=rvts31> из 56 разрядов соединенных блоков, выбираются 48 разрядов ключа в порядке, приведенном в табл. 3.4;</span></p>
                        <p class=rvps595><span class=rvts3923>−</span><span class=rvts93> указанные действия</span><span class=rvts31> повторяются 16 раз.</span></p>
                        <p class=rvps1017><span class=rvts51>Таблица 3.3</span></p>
                        <p style="text-align: center;"><span class=rvts30>Таблица сдвигов, используемых при формировании раундовых подключей</span></p>
                        <div class=rvps30><table width="100%" border=1 cellpadding=4 cellspacing=-1 style="border-width: 0px; border-collapse: collapse;">
                        <tr valign=top>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>i</span></p>
                        </td>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps794><span class=rvts41>0</span></p>
                        </td>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps794><span class=rvts41>1</span></p>
                        </td>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps794><span class=rvts41>2</span></p>
                        </td>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps794><span class=rvts41>3</span></p>
                        </td>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps794><span class=rvts41>4</span></p>
                        </td>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps794><span class=rvts41>5</span></p>
                        </td>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps794><span class=rvts41>6</span></p>
                        </td>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps794><span class=rvts41>7</span></p>
                        </td>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps794><span class=rvts41>8</span></p>
                        </td>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps794><span class=rvts41>9</span></p>
                        </td>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps794><span class=rvts41>10</span></p>
                        </td>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps794><span class=rvts41>11</span></p>
                        </td>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps794><span class=rvts41>12</span></p>
                        </td>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps794><span class=rvts41>13</span></p>
                        </td>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps794><span class=rvts41>14</span></p>
                        </td>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps794><span class=rvts41>15</span></p>
                        </td>
                        </tr>
                        <tr valign=top>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps795><span class=rvts41>s[i]</span></p>
                        </td>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps794><span class=rvts41>1</span></p>
                        </td>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps794><span class=rvts41>1</span></p>
                        </td>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps794><span class=rvts41>2</span></p>
                        </td>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps794><span class=rvts41>2</span></p>
                        </td>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps794><span class=rvts41>2</span></p>
                        </td>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps794><span class=rvts41>2</span></p>
                        </td>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps794><span class=rvts41>2</span></p>
                        </td>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps794><span class=rvts41>2</span></p>
                        </td>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps794><span class=rvts41>1</span></p>
                        </td>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps794><span class=rvts41>2</span></p>
                        </td>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps794><span class=rvts41>2</span></p>
                        </td>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps794><span class=rvts41>2</span></p>
                        </td>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps794><span class=rvts41>2</span></p>
                        </td>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps794><span class=rvts41>2</span></p>
                        </td>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps794><span class=rvts41>2</span></p>
                        </td>
                        <td width="5%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps794><span class=rvts41>1</span></p>
                        </td>
                        </tr>
                        </table>
                        </div>
                        <p class=rvps792><span class=rvts4><br></span></p>
                        <p class=rvps1010><span class=rvts51>Таблица 3.4</span></p>
                        <p style="text-align: center;"><span class=rvts30>Таблица выбора бит при формировании раундовых подключей</span></p>
                        <div class=rvps30><table width="100%" border=1 cellpadding=4 cellspacing=-1 style="border-width: 0px; border-collapse: collapse;">
                        <tr valign=top>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>14</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>17</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>11</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>24</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>1</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>5</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>3</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>28</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>15</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>6</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>21</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>10</span></p>
                        </td>
                        </tr>
                        <tr valign=top>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>23</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>19</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>12</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>4</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>26</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>8</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>16</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>7</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>27</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>20</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>13</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>2</span></p>
                        </td>
                        </tr>
                        <tr valign=top>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>41</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>52</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>31</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>37</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>47</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>55</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>30</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>40</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>51</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>45</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>33</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>48</span></p>
                        </td>
                        </tr>
                        <tr valign=top>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>44</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>49</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>39</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>56</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>34</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>53</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>46</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>42</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>50</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>36</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>29</span></p>
                        </td>
                        <td width="8%" valign=top style="border-width : 1px; border-color: #000000; border-style: solid; padding: 0px 7px;"><p class=rvps99><span class=rvts41>32</span></p>
                        </td>
                        </tr>
                        </table>
                        </div>
                        <p class=rvps4><span class=rvts4><br></span></p>
                        <p class=rvps715><span class=rvts4>Достоинства алгоритма DES:</span></p>
                        <p class=rvps1014><span class=rvts1640>−</span><span class=rvts31> революционность для своего времени;</span></p>
                        <p class=rvps1014><span class=rvts1640>−</span><span class=rvts31> отсутствие практических методов вскрытия более эффективных, чем полный перебор, несмотря многие годы криптоанализа.</span></p>
                        <p class=rvps715><span class=rvts4>Недостатки блочного шифра:</span></p>
                        <p class=rvps1014><span class=rvts1640>−</span><span class=rvts31> основным недостатком данного блочного шифра, обусловившего его замену, является малая длина ключа, которая сегодня может быть вскрыта методом прямого перебора за время менее 3 суток и использованием аппаратуры стоимостью менее 10000$;</span></p>
                        <p class=rvps1014><span class=rvts1640>−</span><span class=rvts31> алгоритм широко использует битовую перестановку, которая легко реализуется аппаратно, но не имеет эффективной программной реализации;</span></p>
                        <p class=rvps1014><span class=rvts1640>−</span><span class=rvts31> малый размер блока недостаточен для эффективного скрытия структуры шифруемых данных, минимально допустимый размер блока сегодня это 128 бит.</span></p>
                        <p class=rvps715><span class=rvts4>За время использования алгоритма DES была наработана огромная криптографическая инфраструктура. Это и большое количество поддерживающей этот алгоритм каналообразующей аппаратуры, и специализированные устройства шифрования, и множество программных реализаций в рамках различных продуктов. Быстро заменить ее было практически нереально, поэтому в качестве промежуточной меры были предприняты попытки усилить этот алгоритм с целью устранения его основного недостатка, до того времени, как будет разработан новый. </span></p>
                        <p class=rvps715><span class=rvts4>Было предложено несколько методов усиления DES с целью устранения основного недостатка </span><span class=rvts1638>−</span><span class=rvts4> малой длины ключа, некоторые из этих методов используются до сих пор. </span></p>
                        <p class=rvps715><span class=rvts30> <strong>Тройной DES</strong>  </span><span class=rvts3926>−</span><span class=rvts30> </span><span class=rvts4>описывается формулой </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00163.png' %}" alt=""><span class=rvts4>, ключ имеет длину 56*3=168 бит, если выбрать все ключи одинаковыми, то алгоритм превращается в DES, т. е. сохраняет совместимость с уже используемым оборудованием. Основной недостаток </span><span class=rvts1638>−</span><span class=rvts4> трехкратное снижение скорости </span><span class=rvts38>шифрования </span><span class=rvts2016>−</span><span class=rvts38> стал причиной, по которой этот алгоритм стал лишь временной заменой алгоритма DES. Данный алгоритм входит в состав протокола SSL .</span></p>
                        <p class=rvps715><span class=rvts30> <strong>DESX</strong> </span><span class=rvts4> – модификация DES,</span><span class=rvts38> разработанная </span><a class=rvts2026 href="#"  OnClick="javascript:NewWindow=window.open('#','NewWindow','width=700,height=700,menubar=no,scrollbars');return false;">Рональдом Ривестом</a><span class=rvts38>, описывается</span><span class=rvts4> формулой </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00164.png' %}" alt=""><span class=rvts4>. Этот алгоритм лишь немногим медленнее DES и не имеет известных уязвимостей, но так и не нашел широкого применения, так как был принят новый стандарт блочного шифра США </span><span class=rvts4310>−</span><span class=rvts4> алгоритм AES.</span></p>
                        <p class=rvps715><span class=rvts65><br></span></p>
                        <p class=rvps715 style="page-break-before: always;"><span class=rvts4><br></span></p>
                        <p class=rvps715><span class=rvts4><br></span></p>
                    </div>
                </div>
            </div>
            <div class="bb-item" id="item31">
                <div class="content">
                    <div class="scroller">
                        <h2>3.2.2. Блочный шифр ГОСТ-28147-89</h2>
                        <p class=rvps741><span class=rvts4>В России установлен единый стандарт криптографического преобразования для информационных систем </span><span class=rvts1638>−</span><span class=rvts4> блочный шифр ГОСТ 28147</span><span class=rvts651>−</span><span class=rvts4>89, введенный в применение в 1989 году. Считается, что разработан он был существенно ранее, и до времени принятия в качестве стандарта несколько лет проходил тестирование. Его применение является обязательным для государственных учреждений, организаций, предприятий, банков и других учреждений, чья деятельность связана с обеспечением информационной безопасности государства (в том числе и для структур министерства обороны РФ). Для прочих организаций и частных лиц его применение носит рекомендательный характер. Блочный шифр ГОСТ 28147-89 является алгоритмом похожим на DES, но спроектированным с учетом опыта применения DES, имеет следующие характеристики:</span></p>
                        <p class=rvps875><span class=rvts1640>−</span><span class=rvts31> структура </span><span class=rvts1640>−</span><span class=rvts31> классическая сеть Фейстеля;</span></p>
                        <p class=rvps875><span class=rvts1640>−</span><span class=rvts31> размер ключа 256 бит;</span></p>
                        <p class=rvps875><span class=rvts1640>−</span><span class=rvts31> размер блока 64 бита;</span></p>
                        <p class=rvps875><span class=rvts1640>−</span><span class=rvts31> количество раундов </span><span class=rvts1640>−</span><span class=rvts31> 32.</span></p>
                        <p class=rvps741><span class=rvts139>Структура раундовой функции представлена на рис. 3.15.</span></p>
                        <p class=rvps741><span class=rvts4><br></span></p>
                        <p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00165.png' %}" alt=""></p>
                        <p style="text-align: center;"><span class=rvts95>Рис. 3.15. Структура раундовой функции блочного шифра ГОСТ 28147</span><span class=rvts4320>−</span><span class=rvts95>89</span></p>
                        <p class=rvps4><span class=rvts4><br></span></p>
                        <p class=rvps767><span class=rvts4>Особенностью этого шифра является использование операции сложения по модулю (обозначается как плюс в квадрате) для добавления подключа и использование секретных блоков подстановок, которые можно рассматривать как долговременный ключ. На последнем раунде перестановка местами блоков не производится, что характерно для шифров структуры классический сети Фейстеля. </span></p>
                        <p class=rvps767><span class=rvts4>Структура ключевого расписания представлена на рис. 3.16.</span></p>
                        <p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00166.png' %}" alt=""></p>
                        <p style="text-align: center;"><span class=rvts95>Рис. 3.16. Структура </span><span class=rvts51>ключевого расписания </span><span class=rvts95>блочного шифра ГОСТ 28147</span><span class=rvts4320>−</span><span class=rvts95>89</span></p>
                        <p class=rvps4><span class=rvts4><br></span></p>
                        <p class=rvps798><span class=rvts30>Достоинства ГОСТ </span><span class=rvts657>28147</span><span class=rvts4321>−</span><span class=rvts657>89</span><span class=rvts30>:</span></p>
                        <p class=rvps1030><span class=rvts1640>−</span><span class=rvts31> отсутствие методов криптоанализа, которые можно осуществить на практике. Теоретически существуют атаки со сложностью</span><img style="vertical-align: middle;" src="{% static 'project/images/img_00167.png' %}" alt=""><span class=rvts31> и большим объемом данных вида открытый текст/шифртекст; </span></p>
                        <p class=rvps1030><span class=rvts1640>−</span><span class=rvts31> допускает эффективную программную и аппаратную реализацию; в отличие от алгоритма DES, в нем отсутствует операция перестановки бит, которая не имеет эффективной программной реализации; большая длина ключа исключает полный перебор.</span></p>
                        <p class=rvps798><span class=rvts30>Недостатки</span><span class=rvts4> </span><span class=rvts30>ГОСТ </span><span class=rvts657>28147</span><span class=rvts4321>−</span><span class=rvts657>89</span><span class=rvts4>:</span></p>
                        <p class=rvps1030><span class=rvts1640>−</span><span class=rvts31> невозможно определить стойкость без знания таблицы замен;</span></p>
                        <p class=rvps1030><span class=rvts1640>−</span><span class=rvts31> реализации с разными таблицами несовместимы между собой;</span></p>
                        <p class=rvps1030><span class=rvts3923>−</span><span class=rvts93> потенциальная возможность использования слабых подстановок; </span></p>
                        <p class=rvps1030><span class=rvts3923>−</span><span class=rvts93> малая длина блока делает неудобным его использование. </span></p>
                        <p class=rvps798 style="page-break-before: always;"><span class=rvts4><br></span></p>
                        <p class=rvps28><span class=rvts4><br></span></p>
                    </div>
                </div>
            </div>
            <div class="bb-item" id="item32">
                <div class="content">
                    <div class="scroller">
                        <h2>3.2.3. Блочный шифр Rijndael (AES)</h2>
                        <p class=rvps171><span class=rvts4>Это наиболее часто использующийся в мире алгоритм шифрования </span><span class=rvts1638>−</span><span class=rvts4> победитель конкурса AES. Особенностью его является широкое использование математического аппарата помехоустойчивых кодов для реализации отдельных структурных элементов.</span></p>
                        <p class=rvps171><span class=rvts4>Имеет несколько модификаций для длины блока и ключа 128, 192 и 256 бит, которые также отличаются по количеству раундов. Рассмотрим версию для 128-битного блока и ключа, являющуюся американским стандартом шифрования. </span></p>
                        <p class=rvps171><span class=rvts4>Параметры шифра:</span></p>
                        <p class=rvps1030><span class=rvts31>1) структура </span><span class=rvts1640>−</span><span class=rvts31> подстановочно-перестановочная сеть;</span></p>
                        <p class=rvps1034><span class=rvts31>2) количество раундов </span><span class=rvts1640>−</span><span class=rvts31> 10;</span></p>
                        <p class=rvps1034><span class=rvts31>3) размер блока </span><span class=rvts1640>−</span><span class=rvts31> 128;</span></p>
                        <p class=rvps1034><span class=rvts31>4) размер ключа </span><span class=rvts1640>−</span><span class=rvts31>128.</span></p>
                        <p class=rvps171><span class=rvts4>Один раунд состоит из следующих шагов (</span><span class=rvts139>рис. 3.17</span><span class=rvts4>):</span></p>
                        <p class=rvps1036><span class=rvts357>а)</span><span class=rvts33> </span><span class=rvts37>ByteSub</span><span class=rvts33> – табличная подстановка 8х8 бит </span><img width=96 height=32 alt="" style="vertical-align: middle; padding : 1px;" src="img/img_00168.png"><span class=rvts357> в поле GF(2</span><span class=rvts4348>8</span><span class=rvts357>), к полученной матрице применяется аффинное преобразование;</span></p>
                        <p class=rvps1036><span class=rvts357>б) </span><span class=rvts37>ShiftRow</span><span class=rvts33> – сдвиг строк в двумерном массиве на различные смещения. Э</span><span class=rvts357>лементы </span><span class=rvts358>i</span><span class=rvts357>-й строки сдвигаются на </span><span class=rvts358>i</span><span class=rvts357> позиций вправо, </span><span class=rvts358>i</span><span class=rvts357> = 1,2,3,4;</span></p>
                        <p class=rvps1036><span class=rvts357>в) </span><span class=rvts37>MixColumn</span><span class=rvts33> – математическое преобразование, перемешивающее данные внутри столбца. </span><img width=441 height=35 alt="" style="vertical-align: middle; padding : 1px;" src="img/img_00169.png"><span class=rvts357> умножается на 03</span><span class=rvts358>x</span><span class=rvts4348>3</span><span class=rvts357>+01</span><span class=rvts358>x</span><span class=rvts4348>2</span><span class=rvts357>+01</span><span class=rvts358>x</span><span class=rvts357>+02 по модулю </span><span class=rvts358>x</span><span class=rvts4348>4</span><span class=rvts357>+1 и образует новый </span><span class=rvts358>k</span><span class=rvts357>-й столбец;</span></p>
                        <p class=rvps1036><span class=rvts357>г) </span><span class=rvts37>AddRoundKey</span><span class=rvts33> – добавление материала ключа операцией XOR.</span><span class=rvts357> Матрица складывается с матрицей, которая зависит от ключа из 128 бит и от номера цикла.</span></p>
                        <p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00170.png' %}" alt=""></p>
                        <p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00171.png' %}" alt=""></p>
                        <p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00172.png' %}" alt=""></p>
                        <p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00173.png' %}" alt=""></p>
                        <p style="text-align: center;"><span class=rvts51>Рис. 3.17. Графическое представление операций «ByteSub», «ShiftRow», «MixColumn» и «AddRoundKey» алгоритма AES</span></p>
                        <p class=rvps1036><span class=rvts357><br></span></p>
                        <p class=rvps775><span class=rvts48><br></span></p>
                        <p class=rvps4><a href="#"><img style="vertical-align: middle;" src="{% static 'project/images/img_00174.png' %}" alt=""></a><a class=rvts65 href="#">Детальное описание алгоритма AES</a></p>
                        <p class=rvps4 style="page-break-before: always;"><span class=rvts4><br></span></p>
                    </div>
                </div>
            </div>
            <div class="bb-item" id="item33">
                <div class="content">
                    <div class="scroller">
                        <h2>3.2.4. Блочный шифр ГОСТ Р 34.12-2015 «КУЗНЕЧИК»</h2>
                        <p class=rvps317><span class=rvts4>Блочный шифр «Кузнечик»&nbsp;(входит в стандарт ГОСТ Р 34.12</span><span class=rvts1638>−</span><span class=rvts4>2015)&nbsp;</span><span class=rvts1638>−</span><span class=rvts4> симметричный алгоритм блочного шифрования с размером блока 128 битов и длиной ключа 256 битов и использующий для генерации раундовых ключей&nbsp;сеть Фейстеля.</span></p>
                        <p class=rvps317><span class=rvts4>Алгоритм «Кузнечик» является более современной и теоретически более стойкой версией его устаревшей версии </span><span class=rvts1638>−</span><span class=rvts4> алгоритма «Магма» (который, по сути, практически без изменений был взят из старого ГОСТ 28147</span><span class=rvts1638>−</span><span class=rvts4>89).</span></p>
                        <p class=rvps317><span class=rvts4>Отличия ГОСТ Р 34.12</span><span class=rvts1638>−</span><span class=rvts4>2015 «Кузнечик» от </span><span class=rvts4362>ГОСТ 28147-89 «Магма»:</span></p>
                        <p class=rvps317><span class=rvts1638>•</span><span class=rvts4> вдвое увеличенная длина блока (</span><span class=rvts51>128 бит, </span><span class=rvts4>против&nbsp;64 бит);</span></p>
                        <p class=rvps317><span class=rvts1638>•</span><span class=rvts4> нетривиальное ключевое расписание (</span><span class=rvts51>сеть Фейстеля как ключевое расписание</span><span class=rvts4>&nbsp;против использования частей секретного ключа в качестве цикловых ключей);</span></p>
                        <p class=rvps317><span class=rvts1638>•</span><span class=rvts4> сокращенное число циклов (</span><span class=rvts51>10 циклов</span><span class=rvts4>&nbsp;против&nbsp;32 циклов);</span></p>
                        <p class=rvps317><span class=rvts1638>•</span><span class=rvts4> принципиально иное устройство самого шифра (</span><span class=rvts51>LSX-шифр</span><span class=rvts4>&nbsp;против&nbsp;сети Фейстеля).</span></p>
                        <p class=rvps317><span class=rvts4>Шифрование основано на последовательном применении нескольких однотипных раундов, каждый из которых содержит три преобразования: сложение с раундовым ключом, преобразование блоком подстановок и линейное преобразование.</span></p>
                        <p class=rvps317><span class=rvts4>128-битный входной вектор очередного раунда складывается побитно с раундовым ключом:</span></p>
                        <div class=rvps317><table width="100%" border=1 cellpadding=1 cellspacing=2 style="border-width: 0px; background-color: #ffffff; border-spacing: 2px;">
                        <tr valign=top>
                        <td width=654 style="border-width : 1px; border-color: #000000; border-style: solid; padding: 1px;"><p class=rvps317><img width=115 height=26 style="vertical-align: middle;" src="{% static 'project/images/img_00175.png' %}" alt=""></p>
                        </td>
                        <td width=819 style="border-width : 1px; border-color: #000000; border-style: solid; padding: 1px;"><p class=rvps317><img width=177 height=26 style="vertical-align: middle;" src="{% static 'project/images/img_00176.png' %}" alt=""></p>
                        </td>
                        </tr>
                        </table>
                        </div>
                        <p class=rvps317><span class=rvts51> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span></p>
                        <p class=rvps317><span class=rvts4>Нелинейное преобразование представляет собой применение к каждому 8-битному подвектору 128-битного входного вектора фиксированной подстановки: </span></p>
                        <div class=rvps317><table width="100%" border=1 cellpadding=1 cellspacing=2 style="border-width: 0px; background-color: #ffffff; border-spacing: 2px;">
                        <tr valign=top>
                        <td width=720 style="border-width : 1px; border-color: #000000; border-style: solid; padding: 1px;"><p class=rvps317><img width=90 height=24 style="vertical-align: middle;" src="{% static 'project/images/img_00177.png' %}" alt=""></p>
                        </td>
                        <td width=906 style="border-width : 1px; border-color: #000000; border-style: solid; padding: 1px;"><p class=rvps317><img width=255 height=52 style="vertical-align: middle;" src="{% static 'project/images/img_00178.png' %}" alt=""></p>
                        </td>
                        </tr>
                        </table>
                        </div>
                        <p class=rvps317><span class=rvts4>Линейное преобразование может быть реализовано не только как обычно в блочных шифрах </span><span class=rvts1638>−</span><span class=rvts4> матрицей, но и с помощью линейного регистра сдвига с обратной связью, который движется 16 раз:</span></p>
                        <div class=rvps317><table width="100%" border=1 cellpadding=1 cellspacing=2 style="border-width: 0px; background-color: #ffffff; border-spacing: 2px;">
                        <tr valign=top>
                        <td width=652 style="border-width : 1px; border-color: #000000; border-style: solid; padding: 1px;"><p class=rvps317><img width=91 height=24 style="vertical-align: middle;" src="{% static 'project/images/img_00179.png' %}" alt=""></p>
                        </td>
                        <td width=821 style="border-width : 1px; border-color: #000000; border-style: solid; padding: 1px;"><p class=rvps317><img width=284 height=52 style="vertical-align: middle;" src="{% static 'project/images/img_00180.png' %}" alt=""></p>
                        </td>
                        </tr>
                        </table>
                        </div>
                        <div class=rvps317><table width="100%" border=1 cellpadding=1 cellspacing=2 style="border-width: 0px; background-color: #ffffff; border-spacing: 2px;">
                        <tr valign=top>
                        <td width=651 style="border-width : 1px; border-color: #000000; border-style: solid; padding: 1px;"><p class=rvps317><img width=89 height=24 style="vertical-align: middle;" src="{% static 'project/images/img_00181.png' %}" alt=""></p>
                        </td>
                        <td width=822 style="border-width : 1px; border-color: #000000; border-style: solid; padding: 1px;"><p class=rvps317><img width=148 height=27 style="vertical-align: middle;" src="{% static 'project/images/img_00182.png' %}" alt=""></p>
                        </td>
                        </tr>
                        </table>
                        </div>
                        <p class=rvps317><span class=rvts4> </span></p>
                        <p class=rvps317><span class=rvts39>Сам регистр (рис. 3.18) реализуется над полем Галуа по модулю неприводимого многочлена степени 8:</span></p>
                        <p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00183.png' %}" alt=""></p>
                        <p style="text-align: center;"><span class=rvts40>Рис. 3.18. Реализация регистра</span></p>
                        <p class=rvps317><span class=rvts4><br></span></p>
                        <p class=rvps317><span class=rvts4>Раундовое преобразование можно изобразить следующим образом (рис. 3.19).</span></p>
                        <p class=rvps317><span class=rvts4><br></span></p>
                        <p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00184.png' %}" alt=""></p>
                        <p style="text-align: center;"><span class=rvts51>Рис. 3.19. Схема раундового преобразования</span></p>
                        <p class=rvps1039><span class=rvts51><br></span></p>
                        <p class=rvps317><span class=rvts4>Процедура генерации раундовых ключей из ключа представлена на рис. 3.20. Первые два получаются разбиением ключа пополам. Далее для выработки очередной пары раундовых ключей используется 8 итераций сети Фейстеля, где, в свою очередь, в качестве раундовых ключей используется счетчиковая последовательность, прошедшая через линейное преобразование алгоритма:</span></p>
                        <p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00185.png' %}" alt=""></p>
                        <p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00186.png' %}" alt=""></p>
                        <p class=rvps597><span class=rvts4><br></span></p>
                        <p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00187.png' %}" alt=""></p>
                        <p class=rvps22><span class=rvts4><br></span></p>
                        <p class=rvps597><a name="_Toc66357388"></a>
                            <img style="vertical-align: middle;" src="{% static 'project/images/img_00188.png' %}" alt=""><span class=rvts4> &nbsp; &nbsp; &nbsp; &nbsp; </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00189.png' %}" alt=""></p>
                        <p style="text-align: center;"><span class=rvts51>Рис. 3.20. Схема процедуры генерации раундовых ключей из ключа</span></p>
                        <p class=rvps317><span class=rvts4><br></span></p>
                        <p class=rvps317><span class=rvts4>В результате, шифрование одного 128-битного входного блока описывается следующим уравнением:</span></p>
                        <p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00190.png' %}" alt=""><span class=rvts4364>.</span></p>
                        <p class=rvps317><span class=rvts4>Расшифрование реализуется обращением базовых преобразований и применением их в обратном порядке (рис. 3.21):</span></p>
                        <p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00191.png' %}" alt=""></p>
                        <p class=rvps22><span class=rvts4><br></span></p>
                        <p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00192.png' %}" alt=""></p>
                        <p style="text-align: center;"><span class=rvts51>Рис. 3.21. Схема расшифрования</span></p>
                        <p class=rvps597 style="page-break-before: always;"><span class=rvts4><br></span></p>
                    </div>
                </div>
            </div>
            <div class="bb-item" id="item34">
                <div class="content">
                    <div class="scroller">
                        <h2>3.2.5. Блочный шифр RC6.</h2>
                        <p class=rvps1047><span class=rvts657>Алгоритм RC6 (</span><span class=rvts4375>Rivest’s Cipher 6</span><span class=rvts657>)</span><span class=rvts38> </span><span class=rvts2016>−</span><span class=rvts38>&nbsp;</span><span class=rvts4374>симметричный</span><span class=rvts4373>&nbsp;</span><span class=rvts4374>блочный</span><span class=rvts38>&nbsp;</span><span class=rvts4373>шифр</span><span class=rvts38>, разработанный Рональдом Ривестом в 1998 году и использующий в качестве своей основы&nbsp;</span><span class=rvts4370>сеть Фестеля</span><span class=rvts38>.</span><span class=rvts4370>&nbsp;</span></p>
                        <p class=rvps1047><span class=rvts4>RC6 представляет собой целое семейство шифров с переменным размером блока, переменным размером ключа от 1 до 32 байт и переменным числом раундов. В шифре вовсе не используются узлы замен, вместо этого используется умножение и циклические сдвиги на переменное число разрядов </span><span class=rvts51>w</span><span class=rvts4>/4-битовых чисел, где </span><span class=rvts51>w</span><span class=rvts4> </span><span class=rvts1638>−</span><span class=rvts4> размер блока данных в битах. В силу этого алгоритм неэффективно реализуется на процессорах без быстрой команды умножения и без команды циклического сдвига на переменное число битов. Кроме того, операция умножения ресурсоемка при аппаратной реализации. По указанным причинам RC6 не был избран в качестве усовершенствованного стандарта шифрования США, хотя на ряде 32-битовых платформ его реализация оказалась существенно эффективней, чем реализация AES.</span></p>
                        <p class=rvps1048><span class=rvts4>Алгоритм RC6 имеет гибкую структуру: помимо секретного ключа, параметрами алгоритма являются следующие:</span></p>
                        <p class=rvps1048><span class=rvts1638>•</span><span class=rvts4> размер слова&nbsp;</span><span class=rvts166>w</span><span class=rvts4>; RC6 шифрует блоками по 4 слова;</span></p>
                        <p class=rvps1048><span class=rvts1638>•</span><span class=rvts4> количество раундов алгоритма&nbsp;</span><span class=rvts166>R</span><span class=rvts4>;</span></p>
                        <p class=rvps1048><span class=rvts1638>•</span><span class=rvts4> размер секретного ключа в байтах&nbsp;</span><span class=rvts166>b</span><span class=rvts4>.</span></p>
                        <p class=rvps1048><span class=rvts38>Для уточнения параметров алгоритма, используемых в его конкретной реализации, применяется обозначение RC6-</span><span class=rvts95>w</span><span class=rvts38>/</span><span class=rvts95>R</span><span class=rvts38>/</span><span class=rvts95>b</span><span class=rvts38>. Поскольку в конкурсе AES 128-битный блок является обязательным, значение </span><span class=rvts95>w</span><span class=rvts38> фиксировано и равно 32. В спецификации алгоритма фиксируется также количество раундов:&nbsp;</span><span class=rvts95>R</span><span class=rvts38>&nbsp;= 20.</span></p>
                        <p class=rvps1048><span class=rvts38>Структура алгоритма представлена на рис. 3.22.</span></p>
                        <p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00193.png' %}" alt=""></p>
                        <p style="text-align: center;"><span class=rvts51>Рис. 3.22. Структура алгоритма RC-6</span></p>
                        <p class=rvps1048><span class=rvts38><br></span></p>
                        <p class=rvps1048><span class=rvts38>Как было сказано выше, в алгоритме используется 20 раундов преобразований, перед которыми выполняется частичное входное отбеливание:</span></p>
                        <p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00194.png' %}" alt=""></p>
                        <p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00195.png' %}" alt=""></p>
                        <p class=rvps1051><span class=rvts38>где&nbsp;</span><span class=rvts95>A</span><span class=rvts38>,&nbsp;</span><span class=rvts95>B</span><span class=rvts38>,&nbsp;</span><span class=rvts95>C</span><span class=rvts38>,&nbsp;</span><span class=rvts95>D</span><span class=rvts38>&nbsp;</span><span class=rvts1638>−</span><span class=rvts38> текущие значения обрабатываемых 32-битных подблоков; </span><span class=rvts95>K</span><span class=rvts2803>0</span><span class=rvts38>...</span><span class=rvts95>K</span><span class=rvts2803>43</span><span class=rvts38>&nbsp;</span><span class=rvts2016>−</span><span class=rvts38> фрагменты расширенного ключа.</span></p>
                        <p class=rvps1040><span class=rvts38>Аналогичным образом выполняется частичное выходное отбеливание:</span></p>
                        <p style="text-align: center;"><span class=rvts2813> &nbsp; &nbsp; &nbsp; &nbsp;</span><img style="vertical-align: middle;" src="{% static 'project/images/img_00196.png' %}" alt=""></p>
                        <p style="text-align: center;"><span class=rvts2813> &nbsp; &nbsp; &nbsp; &nbsp;</span><img style="vertical-align: middle;" src="{% static 'project/images/img_00197.png' %}" alt=""></p>
                        <p class=rvps1040><span class=rvts4>В каждом раунде алгоритма выполняются следующие действия:</span></p>
                        <p style="text-align: center;"><span class=rvts2813> &nbsp; &nbsp; &nbsp; &nbsp;</span><img style="vertical-align: middle;" src="{% static 'project/images/img_00198.png' %}" alt=""></p>
                        <p style="text-align: center;"><span class=rvts2813> &nbsp; &nbsp; &nbsp; &nbsp;</span><img style="vertical-align: middle;" src="{% static 'project/images/img_00199.png' %}" alt=""></p>
                        <p style="text-align: center;"><span class=rvts2813> &nbsp; &nbsp; &nbsp; &nbsp;</span><img style="vertical-align: middle;" src="{% static 'project/images/img_00200.png' %}" alt=""></p>
                        <p style="text-align: center;"><span class=rvts2813> &nbsp; &nbsp; &nbsp; &nbsp;</span><img style="vertical-align: middle;" src="{% static 'project/images/img_00201.png' %}" alt=""></p>
                        <p class=rvps1054><span class=rvts4330>где </span><span class=rvts4376>t</span><span class=rvts4377>1</span><span class=rvts4330> и </span><span class=rvts4376>t</span><span class=rvts4377>2</span><span class=rvts4330> – временные переменные, количество бит вращения на переменное число бит определяется значением 5 младших бит параметра (</span><span class=rvts4376>t</span><span class=rvts4377>1</span><span class=rvts4330> или </span><span class=rvts4376>t</span><span class=rvts4377>2</span><span class=rvts4330>), функция </span><span class=rvts4376>f</span><span class=rvts4330>( )выполняет следующее квадратичное преобразование</span><span class=rvts4> </span><img style="vertical-align: middle;" src="{% static 'project/images/img_00202.png' %}" alt=""></p>
                        <p class=rvps1048><span class=rvts4>В конце каждого раунда выполняется сдвиг </span><span class=rvts38>подблоков (рис. 3.22).</span></p>
                        <p class=rvps1048><span class=rvts4>При расшифровании (рис. 3.23) подключи используются в обратном порядке, наложение подключей вместо сложения по модулю 2</span><span class=rvts363>32</span><span class=rvts4>&nbsp;выполняется вычитанием, а также сдвиг подблоков выполняется в начале раунда и в обратную сторону. Преобразование&nbsp;</span><span class=rvts51>f</span><span class=rvts4>( )&nbsp;не претерпело изменений.</span></p>
                        <p style="text-align: center;"><img style="vertical-align: middle;" src="{% static 'project/images/img_00203.png' %}" alt=""></p>
                        <p style="text-align: center;"><span class=rvts51>Рис. 3.23. Схема расшифрования алгоритмом RC6</span></p>
                        <p class=rvps1049 style="page-break-before: always;"><span class=rvts4><br></span></p>
                    </div>
                </div>
            </div>
            <div class="bb-item" id="item35">
                <div class="content">
                    <div class="scroller">
                        <h2>Контрольные вопросы</h2>
                        <p>1. Что такое перемешивание и рассеивание, почему БШ обязательно должны содержать нелинейные элементы?</p>
                        <p>2. Почему нельзя использовать подстановки большой размерности?</p>
                        <p>3. Что будет, если в шифре отсутствует линейное преобразование?</p>
                        <p>4. Назвать основные варианты построения блочных шифров.</p>
                        <p>5. В чем опасность использования альтернативных вариантов построения блочных шифров?</p>
                        <p>6. Назвать основные режимы применения БШ.</p>
                    </div>
                </div>
            </div>
        </div>
        <nav>
            <span id="bb-nav-prev">&larr;</span>
            <span id="bb-nav-next">&rarr;</span>
        </nav>
        <span id="tblcontents" class="menu-button">Содержание</span>
    </div>
</div>
{% endblock %}