<!DOCTYPE html>
<html lang="ru">
<head>
    <title>Без названия.&nbsp;4.4.2. Классификация поточных алгоритмов шифрования</title>
    <meta charset="UTF-8"> 
    <meta name="generator" content="SunRav BookEditor"> 	
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="4.4.2. Классификация поточных алгоритмов шифрования">
    <link href="theme/bootstrap.min.css" rel="stylesheet">
    <link href="theme/simple-sidebar.css" rel="stylesheet">
	<link href="styles.css" rel="stylesheet">   

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>

<body>

    <div id="wrapper">
        <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav"><li class="sidebar-brand"><a href="index.html">Без названия</a></li><li ><a href='20.html'>&nbsp;&nbsp;<span class='glyphicon glyphicon-folder-close' aria-hidden='true'></span>&nbsp;Учебное пособие КМЗИ</a></li><li ><a href='1160.html'>&nbsp;&nbsp;&nbsp;&nbsp;<span class='glyphicon glyphicon-folder-close' aria-hidden='true'></span>&nbsp;Титульный экран</a></li><li ><a href='1170.html'>&nbsp;&nbsp;&nbsp;&nbsp;<span class='glyphicon glyphicon-file' aria-hidden='true'></span>&nbsp;Оглавление</a></li><li ><a href='40.html'>&nbsp;&nbsp;&nbsp;&nbsp;<span class='glyphicon glyphicon-file' aria-hidden='true'></span>&nbsp;Предисловие</a></li><li ><a href='50.html'>&nbsp;&nbsp;&nbsp;&nbsp;<span class='glyphicon glyphicon-folder-close' aria-hidden='true'></span>&nbsp;1. Основы криптографии как науки о засекречивании информации</a></li><li ><a href='70.html'>&nbsp;&nbsp;&nbsp;&nbsp;<span class='glyphicon glyphicon-folder-close' aria-hidden='true'></span>&nbsp;2. Криптографические нападения и понятие о криптоанализе, надежность шифров</a></li><li ><a href='80.html'>&nbsp;&nbsp;&nbsp;&nbsp;<span class='glyphicon glyphicon-folder-close' aria-hidden='true'></span>&nbsp;3. Современные блочные шифры и методы из криптоанализа</a></li><li ><a href='90.html'>&nbsp;&nbsp;&nbsp;&nbsp;<span class='glyphicon glyphicon-folder-close' aria-hidden='true'></span>&nbsp;4. Вспомогательные криптографические примитивы</a></li><li ><a href='220.html'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class='glyphicon glyphicon-folder-close' aria-hidden='true'></span>&nbsp;4.1. Вероятностное шифрование</a></li><li ><a href='230.html'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class='glyphicon glyphicon-folder-close' aria-hidden='true'></span>&nbsp;4.2. Блочные шифры на основе управляемых операций</a></li><li ><a href='240.html'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class='glyphicon glyphicon-folder-close' aria-hidden='true'></span>&nbsp;4.3. Криптографические хэш функции</a></li><li ><a href='250.html'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class='glyphicon glyphicon-folder-close' aria-hidden='true'></span>&nbsp;4.4. Поточные алгоритмы шифрования</a></li><li ><a href='800.html'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class='glyphicon glyphicon-file' aria-hidden='true'></span>&nbsp;4.4.1. Определение и структурные элементы поточных шифров</a></li><li class='sidebar-active'><a href='810.html'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class='glyphicon glyphicon-file' aria-hidden='true'></span>&nbsp;4.4.2. Классификация поточных алгоритмов шифрования</a></li><li ><a href='820.html'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class='glyphicon glyphicon-file' aria-hidden='true'></span>&nbsp;4.4.3. Примеры поточных алгоритмов шифрования</a></li><li ><a href='1790.html'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class='glyphicon glyphicon-file' aria-hidden='true'></span>&nbsp;Контрольные вопросы</a></li><li ><a href='1280.html'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class='glyphicon glyphicon-file' aria-hidden='true'></span>&nbsp;Тест к главе 4</a></li><li ><a href='100.html'>&nbsp;&nbsp;&nbsp;&nbsp;<span class='glyphicon glyphicon-folder-close' aria-hidden='true'></span>&nbsp;5. Криптосистемы с открытым ключом</a></li><li ><a href='110.html'>&nbsp;&nbsp;&nbsp;&nbsp;<span class='glyphicon glyphicon-folder-close' aria-hidden='true'></span>&nbsp;6. Криптографические методы в современных средствах защиты информации в компьютерных системах</a></li><li ><a href='1320.html'>&nbsp;&nbsp;&nbsp;&nbsp;<span class='glyphicon glyphicon-folder-close' aria-hidden='true'></span>&nbsp;Справочные материалы</a></li><li ><a href='2020.html'>&nbsp;&nbsp;&nbsp;&nbsp;<span class='glyphicon glyphicon-file' aria-hidden='true'></span>&nbsp;Список литературы</a></li>            </ul>
        </div>
        <!-- /#sidebar-wrapper -->

        <!-- Page Content -->
        <div id="page-content-wrapper">
            <div class="container-fluid">
                <div class="row">
                    <div class="col-lg-12">
                        <h1><a title="Показать/скрыть меню" href="#menu-toggle" class="btn btn-default" id="menu-toggle"><span class="glyphicon glyphicon-menu-hamburger" aria-hidden="true"></span></a> 4.4.2. Классификация поточных алгоритмов шифрования</h1>
						<hr>
                        <h3 class=rvps1022><span class=rvts0><span class=rvts29>4.4.2. Классификация поточных алгоритмов шифрования</span></span></h3>
<p class=rvps767><span class=rvts139>Пусть</span><span class=rvts4> </span><span class=rvts51>X</span><span class=rvts4> – множество открытых текстов, </span><span class=rvts51>Y</span><span class=rvts4> – множество шифртекстов, </span><span class=rvts51>K</span><span class=rvts4> </span><span class=rvts1638>−</span><span class=rvts4> пространство ключей и </span><span class=rvts51>S</span><span class=rvts4> – пространство внутренних состояний, тогда поточный шифр определяется как</span></p>
<p class=rvps22><img width=252 height=55 alt="" style="padding : 1px;" src="img/img_00456.png"></p>
<p class=rvps1243><span class=rvts4>где </span><span class=rvts51>F</span><span class=rvts4> – функция состояния, а </span><span class=rvts51>f</span><span class=rvts4> </span><span class=rvts1638>−</span><span class=rvts4> функция выхода. </span></p>
<p class=rvps767><span class=rvts139>Различают</span><span class=rvts4> два основных вида поточных шифров: самосинхронизирующиеся и синхронные поточные шифры.</span></p>
<p class=rvps767><span class=rvts166>Самосинхронизируюшиеся шифры</span><span class=rvts4> </span><span class=rvts1638>−</span><span class=rvts4> </span><span class=rvts139>алгоритмы</span><span class=rvts4>, в которых внутренне состояние генератора зависит только от </span><span class=rvts51>n</span><span class=rvts4> предыдущих бит шифртекста, поэтому генератор на приемной стороне автоматически синхронизируется с передающим после приема </span><span class=rvts51>n</span><span class=rvts4> &nbsp;символов шифртекста. Такой шифр имеет свойство ограниченного распространения ошибок, т. е. автоматически восстанавливает правильное состояние после обработки </span><span class=rvts51>n</span><span class=rvts4> символов из канала связи. </span></p>
<p class=rvps767><span class=rvts4>Общая схема самосинхронизирующегося шифра приведена на рис. 4.31, где </span><span class=rvts51>f</span><span class=rvts4> </span><span class=rvts1638>−</span><span class=rvts4> это функция генерации ключевого потока. </span></p>
<div class=rvps969><table border=0 cellpadding=4 cellspacing=0 style="border-width: 0px; border-spacing: 0px; margin: 0px auto;">
<tr valign=top>
<td width=628 valign=top style="padding: 0px 7px;"><p class=rvps969><img alt="" style="padding : 1px;" src="img/img_00457.png"></p>
</td>
</tr>
<tr valign=top>
<td width=628 valign=top style="padding: 0px 7px;"><p class=rvps1339><span class=rvts51>Рис. 4.31. </span><span class=rvts95>Общая схема самосинхронизирующегося шифра</span></p>
</td>
</tr>
</table>
</div>
<p class=rvps767><span class=rvts4><br></span></p>
<p class=rvps767><span class=rvts4>Наиболее распространенный способ реализации </span><span class=rvts1638>−</span><span class=rvts4> это применение блочного шифра в режиме обратной связи по шифртексту (CFB). В простейшем случае используются все байты шифртекста (рис. 4.32). </span></p>
<p class=rvps767><span class=rvts4>Рассмотрим более стойкую схему, в которой от каждого блока шифртекста используется только один байт, внутреннее состояние изменяется на каждом шаге и в канал связи не передается блок шифртекста целиком, что затрудняет применение методов криптоанализа блочных шифров.</span></p>
<div class=rvps969><table border=0 cellpadding=4 cellspacing=0 style="border-width: 0px; border-spacing: 0px; margin: 0px auto;">
<tr valign=top>
<td width=962 valign=top style="padding: 0px 7px;"><p class=rvps969><img alt="" style="padding : 1px;" src="img/img_00458.png"></p>
</td>
</tr>
<tr valign=top>
<td width=962 valign=top style="padding: 0px 7px;"><p class=rvps1339><span class=rvts51>Рис. 4.32. </span><span class=rvts95>Общая схема наиболее распространенного способа реализации поточного шифрования</span></p>
</td>
</tr>
</table>
</div>
<p class=rvps767><span class=rvts4><br></span></p>
<p class=rvps767><span class=rvts4>Применение самосинхронизирующихся шифров наиболее характерно для военной криптографии, поэтому открытых работ по этой тематике достаточно мало. Рассмотрим пример самосинхронизирующегося поточного шифра, который можно построить с использованием любого блочного шифра (рис. 4.33). Этот шифр является байтовым, и использует байтовый регистр сдвига размером 16 байт. Изначально этот регистр заполняется некоторым начальным значением с использованием ключа.</span></p>
<p class=rvps767><span class=rvts4><br></span></p>
<div class=rvps969><table border=0 cellpadding=4 cellspacing=0 style="border-width: 0px; border-spacing: 0px; margin: 0px auto;">
<tr valign=top>
<td width=628 valign=top style="padding: 0px 7px;"><p class=rvps969><img alt="" style="padding : 1px;" src="img/img_00459.png"></p>
</td>
</tr>
<tr valign=top>
<td width=628 valign=top style="padding: 0px 7px;"><p class=rvps1339><span class=rvts51>Рис. 4.33. Пример самосинхронизирующегося поточного шифра</span></p>
</td>
</tr>
</table>
</div>
<p class=rvps767><span class=rvts4><br></span></p>
<p class=rvps767><span class=rvts4>При шифровании каждого байта значение передается в алгоритм шифрования, из результата шифрования берется один старший байт и складывается по модулю 2 с открытым текстом для получение шифртекста. При этом исходное значение регистра сдвигается на один байт влево, а на место освободившегося правого байта ставится получившийся в этом цикле байт шифртекста.</span></p>
<p class=rvps767><span class=rvts4>В случае рассинхронизации или ошибки в канале связи 16 байт будут приняты неправильно, а следующие байты опять начнут приниматься правильно.</span></p>
<p class=rvps767><span class=rvts166>Синхронные шифры</span><span class=rvts4> </span><span class=rvts1638>−</span><span class=rvts4> поточные алгоритмы шифрования, в которых гамма не зависит от открытого или зашифрованного текста. </span></p>
<p class=rvps767><span class=rvts4>Основная сложность, применительно к ним, заключается в необходимости синхронизации генераторов на приемной и передающей стороне. Такие шифры описываются следующими формулами:</span></p>
<p class=rvps22><img width=248 height=28 alt="" style="padding : 1px;" src="img/img_00460.png"></p>
<p class=rvps1340><span class=rvts4>где </span><span class=rvts51>F</span><span class=rvts4> </span><span class=rvts1638>−</span><span class=rvts4> это функция обновления внутреннего состояния, а </span><span class=rvts51>f</span><span class=rvts4> &nbsp;</span><span class=rvts1638>−</span><span class=rvts4> функция генерации ключевого потока.</span></p>
<p class=rvps767><span class=rvts4>Синхронные шифры классифицируются по виду зависимости от ключа (рис. 4.34):</span></p>
<div class=rvps969><table border=0 cellpadding=4 cellspacing=0 style="border-width: 0px; border-spacing: 0px; margin: 0px auto;">
<tr valign=top>
<td width=1043 valign=top style="padding: 0px 7px;"><p class=rvps969><img alt="" style="padding : 1px;" src="img/img_00461.png"></p>
</td>
</tr>
<tr valign=top>
<td width=1043 valign=top style="padding: 0px 7px;"><p class=rvps1356><span class=rvts51>Рис. 4.34. </span><span class=rvts95>Синхронные функции: </span><br><span class=rvts95>справа </span><span class=rvts4320>−</span><span class=rvts95> режим счетчика; слева </span><span class=rvts4320>−</span><span class=rvts95> режим внутренней обратной связи</span></p>
<p class=rvps1356><span class=rvts95><br></span></p>
</td>
</tr>
</table>
</div>
<p class=rvps767><span class=rvts30><br></span></p>
<h4 class=rvps1331><span class=rvts0><span class=rvts50>Режим счетчика</span></span></h4>
<p class=rvps767><span class=rvts4>Функция состояния не зависит от бит ключа и проходит через все пространство состояний или большую его часть:</span></p>
<p class=rvps22><img width=232 height=28 alt="" style="padding : 1px;" src="img/img_00462.png"></p>
<p class=rvps767><span class=rvts4>Такими функциями являются счетчики и регистры с линейной обратной связью с максимальным периодом и др. Их стойкость основана на стойкости выходной функции </span><img width=17 height=22 alt="" style="vertical-align: text-bottom; padding : 1px;" src="img/img_00463.png"><span class=rvts4>.</span></p>
<p class=rvps767><span class=rvts4><br></span></p>
<h4 class=rvps1331><span class=rvts0><span class=rvts50>Режим внутренней обратной связи</span></span></h4>
<p class=rvps767><span class=rvts4>Выходная функция </span><img width=17 height=22 alt="" style="vertical-align: middle; padding : 1px;" src="img/img_00464.png"><span class=rvts4> не зависит от ключа: </span></p>
<p class=rvps22><img width=232 height=28 alt="" style="padding : 1px;" src="img/img_00465.png"></p>
<p class=rvps767><span class=rvts4>Ключ может использоваться только для задания начального состояния и его обновления в процессе шифрования.</span></p>
<p class=rvps767><span class=rvts4>Если в процессе передачи произойдет искажение хотя бы одного бита, то вся остальная часть сообщения будет расшифрована неверно и для восстановления правильного приема потребуется выполнить повторную синхронизацию. Обычно это выполняется вставкой в сообщение специальных маркеров. Синхронный потоковый шифр может быть реализован с помощью блочного шифра в режиме обратной связи по выходу (OFB). </span></p>
<p class=rvps767><span class=rvts4>Так, например, синхронный поточный шифр A5, применяемый в сетях стандарта GSM в Европе, использует фреймы размером 228 бит и начальное значение определяется из номера фрейма (рис. 4.35).</span></p>
<div class=rvps969><table border=0 cellpadding=4 cellspacing=0 style="border-width: 0px; border-spacing: 0px; margin: 0px auto;">
<tr valign=top>
<td width=628 valign=top style="padding: 0px 7px;"><p class=rvps969><img alt="" style="padding : 1px;" src="img/img_00466.png"></p>
</td>
</tr>
<tr valign=top>
<td width=628 valign=top style="padding: 0px 7px;"><p class=rvps1339><span class=rvts51>Рис. 4.35. Принцип синхронизации в поточном шифре A5</span></p>
</td>
</tr>
</table>
</div>
<p class=rvps767><span class=rvts4><br></span></p>
<p class=rvps767><span class=rvts4><br></span></p>

                    </div>
					<div class="row">
						<div class="col-xs-6">
						<a title="К предыдущей главе" href="800.html" class="btn btn-default btn-sm" id="menu-toggle"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Назад</a>							
						</div>
						<div class="col-xs-6 text-right">
						<a title="К следующей главе" href="820.html" class="btn btn-default btn-sm" id="menu-toggle">Вперед<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>							
						</div>
					</div>
                </div>
            </div>
<footer>
        <hr>
        <p><p class=rvps2><span class=rvts4><br></span></p>
</p>
      </footer>			
        </div>
        <!-- /#page-content-wrapper -->

    </div>
    <!-- /#wrapper -->

    <!-- jQuery -->
    <script src="theme/jquery-1.12.1.min.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="theme/bootstrap.min.js"></script>

    <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>

</body>

</html>